<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>linux基本命令手册 | Outing myself</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="null"><meta name="description" content="日常学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://github.com/BUGIsOne/2019/09/17/Linux基本命令手册/index.html"><link rel="icon" type="image/png" href="../images/164009528604.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Rakel's bolg"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://blog.static.minfive.com/other/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Rakel's bolg" alt="Rakel's bolg"><img src="../images/164009528604.jpg" alt="Rakel's bolg"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="linux基本命令手册"></div><header class="post__info"><h1 class="post__title">linux基本命令手册</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/BUGIsOne">Rakel</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-09-17</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/linux/">Linux</a></li></ul></div></div></header><div class="post__content"><h2 id="在线浏览地址-https-www-zybuluo-com-re-start-note-1232503"><a href="#在线浏览地址-https-www-zybuluo-com-re-start-note-1232503" class="headerlink" title="在线浏览地址:https://www.zybuluo.com/re-start/note/1232503"></a>在线浏览地址:<a href="https://www.zybuluo.com/re-start/note/1232503" target="_blank" rel="noopener">https://www.zybuluo.com/re-start/note/1232503</a></h2><h2 id="一、Linux终端、内核等概念"><a href="#一、Linux终端、内核等概念" class="headerlink" title="一、Linux终端、内核等概念"></a>一、Linux终端、内核等概念</h2><ul><li><em>终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登陆就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录。在物理机系统上你可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换。</em></li><li><em>Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。普通意义上的 Shell 就是可以接受用户输入命令的程序。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。同样的 UNIX/Linux 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。</em></li></ul><p>&emsp;</p><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><h3 id="查询命令-man"><a href="#查询命令-man" class="headerlink" title="查询命令 man"></a>查询命令 <code>man</code></h3><ul><li><p><code>man</code> <code>man &lt;命令&gt;</code>可查询该命令<br>其实ubuntu有man的中文包，只需几行命令安装配置即可显示中文帮助</p><pre><code>apt-get install manpages-zh
vi /etc/manpath.config
:1,$s#/usr/share/man#/usr/share/man/zh_CN#g</code></pre></li><li><p>&lt;命令&gt; –help</p></li></ul><p>&emsp;</p><h3 id="创建文件-touch"><a href="#创建文件-touch" class="headerlink" title="创建文件 touch"></a>创建文件 <code>touch</code></h3><ul><li><code>touch</code> 命令创建文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch asd.txt fgh.txt</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;</p><h3 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h3><ul><li><code>Ctrl+c</code> 你想要立即停止并恢复到你可控的状态,使用Ctrl+c键来强行中断当前程序（你可以放心它并不会使终端退出）。<br><code>Ctrl+d</code> 键盘输入结束或退出终端<br><code>Ctrl+s</code> 暂停当前程序，暂停后按下任意键恢复运行<br><code>Ctrl+z</code> 将当前程序放到后台运行，恢复到前台为命令<code>fg</code><br><code>Ctrl+a</code> 将光标移至输入行头，相当于<code>Home</code>键<br><code>Ctrl+e</code> 将光标移至输入行末，相当于<code>End</code>键<br><code>Ctrl+k</code> 删除从光标所在位置到行末</li><li><code>Alt+Backspace</code> 向前删除一个单词</li><li><code>Tab</code> 使用Tab键来进行命令补全,当你忘记某个命令的全称时可以只输入它的开头的一部分，然后按下Tab键就可以得到提示或者帮助完成.</li><li><code>Shift+PgUp</code> 将终端显示向上滚动<br><code>Shift+PgDn</code> 将终端显示向下滚动</li><li>星号（*）和问号（?），用来对字符串进行模糊匹配<br>使用通配符:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls *.txt</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;</p><h3 id="用户快捷键-who"><a href="#用户快捷键-who" class="headerlink" title="用户快捷键 who"></a>用户快捷键 <code>who</code></h3><table><thead><tr><th>按键</th><th>用法</th></tr></thead><tbody><tr><td>who</td><td>显示当前用户</td></tr><tr><td>whoami</td><td>查看用户</td></tr><tr><td>-a</td><td>打印能打印的全部</td></tr><tr><td>-d</td><td>打印死掉的程序</td></tr><tr><td>-m</td><td>查看用户</td></tr><tr><td>-q</td><td>用户登录数及用户名</td></tr><tr><td>-u</td><td>当前登录用户信息</td></tr><tr><td>-r</td><td>运行等级</td></tr></tbody></table><p>&emsp;</p><h2 id="三、用户权限"><a href="#三、用户权限" class="headerlink" title="三、用户权限"></a>三、用户权限</h2><ul><li><code>root</code> 权限，系统权限的一种，与 SYSTEM 权限可以理解成一个概念，但高于<code>Administrator</code>权限，<strong>root 是 Linux 和 UNIX 系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，</strong>所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限，用 Windows 的方法理解也就是将自己的非法帐户添加到 Administrators 用户组。更比如安卓操作系统中（基于 Linux 内核）获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行所有增、删、改、查的操作。</li><li>创建用户<br>这里就要用到<code>sudo</code>这个命令了。<strong>不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。</strong><table><thead><tr><th>按键</th><th align="center">用法</th></tr></thead><tbody><tr><td><code>su &lt;user&gt;</code></td><td align="center">可以切换到用户user，执行时需要输入目标用户的密码</td></tr><tr><td><code>sudo ls</code></td><td align="center">询问当前用户是否是sudu组</td></tr><tr><td><code>su -l &lt;user&gt;</code></td><td align="center">切换用户</td></tr><tr><td><code>su - &lt;user&gt;</code></td><td align="center">命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。</td></tr><tr><td><code>sudo &lt;cmd&gt;</code></td><td align="center">可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。</td></tr><tr><td><code>sudo adduser &lt;user&gt;</code></td><td align="center">添加新用户，必须是sudo用户来操作</td></tr><tr><td><code>sudo deluser &lt;user&gt;</code></td><td align="center">删除用户，同上</td></tr></tbody></table></li></ul><p><strong>注：符号&lt;&gt;是不用输入的</strong></p><ul><li>用户组 <code>group</code><br>查看所属用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组</li></ul><p>方法一：</p><pre><code>groups &lt;user&gt;</code></pre><p>方法二：</p><pre><code>cat /etc/group/ | sort</code></pre><p><code>| sort</code> 以字典排序,或者可以过滤不想看到的内容</p><pre><code>cat /etc/group | grep -E &quot;&lt;user&gt;&quot;</code></pre><p>得到格式如下：</p><pre><code>group_name:password:GID:user_list</code></pre><p>你看到上面的 password 字段为一个 x 并不是说密码就是它，只是表示密码不可见而已。</p><ul><li><p>sudo用户组<br>/etc/sudoers.d/shiyanlou 文件，我们在 /etc/sudoers.d 目录下创建了这个文件，从而给 shiyanlou 用户赋予了 sudo 权限。</p></li><li><p>使用<code>usermod</code>将其它用户加入 sudo 用户组</p></li></ul><p>先进入该用户查看是否在sudo组：</p><pre><code>$ su -l lilei</code></pre><p>$ sudo ls</p><p>使用 root 用户为其它用户添加用户组</p><pre><code>$ su shiyanlou  //此处需要输入shiyanlou用户密码</code></pre><p>$ groups lilei<br>$ sudo usermod -G sudo lilei<br>$ groups lilei //显示成功</p><p>&emsp;</p><h2 id="四、文件权限"><a href="#四、文件权限" class="headerlink" title="四、文件权限"></a>四、文件权限</h2><p><img src="http://img2.ph.126.net/0nvKpkOP3SpXemmXwsFCAg==/3287909203057689698.png" alt="图"></p><ul><li><p>一个目录同时具有<strong>读权限</strong>和<strong>执行权限</strong>才可以打开并查看内部文件，而一个目录要有<strong>写权限</strong>才允许在其中创建其它文件</p></li><li><p><code>ls</code></p><table><thead><tr><th>按键</th><th align="center">用法</th></tr></thead><tbody><tr><td>-l</td><td align="center">使用较长格式列出文件</td></tr><tr><td>-lh</td><td align="center">更直观的查看文件的大小</td></tr><tr><td>-A</td><td align="center">显示除了 .（当前目录）和 ..（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件）。</td></tr><tr><td>ll &lt;文件名&gt;`</td><td align="center">显示该文件信息</td></tr></tbody></table></li></ul><ul><li>变更文件所属用户</li></ul><p>假设lilei已创建iphone6，返回到shiyanlou下执行：</p><pre><code>$ cd /home/lilei</code></pre><p>$ ls iphone6<br>$ sudo chown shiyanlou iphone6</p><ul><li>设置文件权限</li></ul><p>方法一：</p><pre><code>$ chmod 600 iphone6 </code></pre><p>因为-r：4 -w：2 -x: 1 ， 所以总共是7。格式d———，每三个分别代表拥有者，所属用户组，其他用户。<br>方法二：</p><pre><code>$ chmod go-rw iphone6</code></pre><p>g、 u还有 o 分别表示 group、user 和 other，+ 和 - 分别表示增加和去掉相应的权限</p><p>&emsp;</p><h2 id="五、目录-文件操作"><a href="#五、目录-文件操作" class="headerlink" title="五、目录,文件操作"></a>五、目录,文件操作</h2><h3 id="显示结构-tree-lt-目录名-gt"><a href="#显示结构-tree-lt-目录名-gt" class="headerlink" title="显示结构 tree &lt;目录名&gt;"></a>显示结构 <code>tree &lt;目录名&gt;</code></h3><pre><code>$ tree /</code></pre><p>若提示not found:</p><pre><code>$ sudo apt-get update</code></pre><p>$ sudo apt-get install tree</p><ul><li>关于绝对路径，简单地说就是以根” / “目录为起点的完整路径，以你所要到的目录为终点，表现形式如： /usr/local/bin，</li><li>相对路径，也就是相对于你当前的目录的路径，<strong>相对路径是以当前目录 . 为起点，以你所要到的目录为终点，</strong>表现形式如： usr/local/bin （这里假设你当前目录为根目录）。你可能注意到，<strong>*我们表示相对路径实际并没有加上表示当前目录的那个 . 。而是直接以目录名开头，因为这个 usr 目录为 / 目录下的子目录，是可以省略这个 . 的。</strong></li></ul><p>提示：在进行目录切换的过程中请多使用 Tab 键自动补全，可避免输入错误，连续按两次 Tab 可以显示全部候选结果。</p><p>&emsp;</p><h3 id="创建新目录-mkdir"><a href="#创建新目录-mkdir" class="headerlink" title="创建新目录 mkdir"></a>创建新目录 <code>mkdir</code></h3><ul><li><p><code>-p</code> 同时创建一个多级目录</p><pre><code>$ mkdir -p father/son/grandson</code></pre></li></ul><p>&emsp;</p><h3 id="复制文件到一个目录-cp"><a href="#复制文件到一个目录-cp" class="headerlink" title="复制文件到一个目录 cp"></a>复制<strong>文件</strong>到一个目录 <code>cp</code></h3><pre><code>$ cp test father/son/grandson</code></pre><ul><li><p>复制<strong>目录</strong>到一个目录，加上-r或者-R：</p><pre><code>$ cp -r father family</code></pre></li></ul><p>&emsp;</p><h3 id="删除文件rm-lt-文件名-gt-，rm-f-lt-文件名-gt-强制删除"><a href="#删除文件rm-lt-文件名-gt-，rm-f-lt-文件名-gt-强制删除" class="headerlink" title="删除文件rm &lt;文件名&gt;，rm -f &lt;文件名&gt; 强制删除"></a>删除文件<code>rm &lt;文件名&gt;</code>，<code>rm -f &lt;文件名&gt;</code> 强制删除</h3><p>若想删除目录，加上参数 <code>-r</code></p><p>&emsp;</p><h3 id="移动文件-多个文件-到目录-mv-文件名1-（文件名2）-目录"><a href="#移动文件-多个文件-到目录-mv-文件名1-（文件名2）-目录" class="headerlink" title="移动文件(多个文件)到目录 mv 文件名1 （文件名2） 目录"></a>移动<strong>文件(多个文件)</strong>到目录 <code>mv 文件名1 （文件名2） 目录</code></h3><h3 id="重命名文件mv-旧的文件名-新的文件名"><a href="#重命名文件mv-旧的文件名-新的文件名" class="headerlink" title="重命名文件mv 旧的文件名 新的文件名"></a>重命名文件<code>mv 旧的文件名 新的文件名</code></h3><p>&emsp;</p><h3 id="批量更名-rename"><a href="#批量更名-rename" class="headerlink" title="批量更名 rename"></a>批量更名 <code>rename</code></h3><p>使用通配符批量创建 5 个文件:</p><pre><code>$ touch file{1..5}.txt</code></pre><p>批量将这 5 个后缀为 .txt 的文本文件重命名为以.c为后缀的文件:<br>$ rename ‘s/.txt/.c/‘ *.txt<br>批量将这 5 个文件，文件名和后缀改为大写:<br>$ rename ‘y/a-z/A-Z/‘ *.c</p><p>&emsp;</p><h3 id="查看文件-cat"><a href="#查看文件-cat" class="headerlink" title="查看文件 cat"></a>查看文件 <code>cat</code></h3><p>可以加上 <code>-n</code> 参数显示行号：</p><pre><code>$ cat -n passwd</code></pre><p>使用 more 和 less 命令分页查看文件</p><pre><code>$ more passwd</code></pre><p>使用 head 和 tail 命令查看文件，它们一个是只查看文件的头几行（默认为 10 行，不足 10 行则显示全部）和尾几行。甚至更直接的只看一行， 加上 -n 参数，后面紧跟行数：</p><pre><code>$ tail -n 1 /etc/passwd</code></pre><p>关于 <code>tail</code> 命令，不得不提的还有它一个很牛的参数 <code>-f</code>，这个参数可以实现不停地读取某个文件的内容并显示。<strong>这可以让我们动态查看日志，达到实时监视的目的。</strong></p><ul><li><p>我们通常使用 file 命令查看文件的类型：</p><pre><code>$ file /bin/ls</code></pre></li></ul><p>&emsp;</p><h2 id="六、环境变量"><a href="#六、环境变量" class="headerlink" title="六、环境变量"></a>六、环境变量</h2><h3 id="创建环境变量-declare"><a href="#创建环境变量-declare" class="headerlink" title="创建环境变量 declare"></a>创建环境变量 <code>declare</code></h3><ul><li><p>使用 declare 命令创建一个变量名为 tmp 的变量：</p><pre><code>$ declare tmp</code></pre></li><li><p>其实也可以不用 declare 预声明一个变量，直接即用即创建</p><pre><code>$ tmp=shiyanlou</code></pre></li></ul><p>&emsp;</p><h3 id="读取变量值-echo"><a href="#读取变量值-echo" class="headerlink" title="读取变量值 echo"></a>读取变量值 <code>echo</code></h3><ul><li><p>读取变量的值，使用 echo 命令和 $ 符号</p><pre><code>$ echo $tmp</code></pre></li></ul><p>&emsp;</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>通常我们会涉及到的变量类型有三种：<br>当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。<br>Shell 本身内建的变量。<br>从自定义变量导出的环境变量。<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。</td></tr><tr><td>env</td><td>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td></tr><tr><td>export</td><td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td></tr><tr><td><img src="http://img1.ph.126.net/V-AyjEHXYtddi0iqWdnsNg==/1387671635283821788.png" alt="04"></td><td></td></tr></tbody></table></li></ul><p>&emsp;</p><ul><li><p>Linux 变量可分为两类：<br>永久的：需要修改配置文件，变量永久生效；<br>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</p></li><li><p>介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell</p></li><li><p>变量和环境变量。<strong>.profile 可以用<code>ls -a</code>查看。这个.profile 只对当前用户永久生效。而写在/etc/profile 里面的是对所有用户永久生效，</strong>所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量。</p></li></ul><p>&emsp;</p><h3 id="创建-Shell-脚本文件："><a href="#创建-Shell-脚本文件：" class="headerlink" title="创建 Shell 脚本文件："></a>创建 Shell 脚本文件：</h3><pre><code>$ gedit hello_shell.sh
为文件添加可执行权限：

$ chmod 755 hello_shell.sh、
执行脚本

$ ./hello_shell.sh
创建一个 C 语言“ hello world ”程序：

$ gedit hello_world.c
保存后使用 gcc 生成可执行文件：

$ gcc -o hello_world hello_world.c</code></pre><p>要么在命令所在路径，否则提示命令找不到，如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 PATH 环境变量了。</p><p>&emsp;</p><h3 id="添加自定义路径到-PATH-环境变量"><a href="#添加自定义路径到-PATH-环境变量" class="headerlink" title="添加自定义路径到 PATH 环境变量"></a>添加自定义路径到 <code>PATH</code> 环境变量</h3><pre><code>$ PATH=$PATH:/home/shiyanlou/mybin</code></pre><p>注意这里一定要使用绝对路径。<br>现在你就可以在任意目录执行那两个命令了（注意需要去掉前面的 ./）。一旦退出终端，再打开就会发现又失效了。<br><code>zsh</code> 的配置文件是 .zshrc，相应 Bash 的配置文件为 .bashrc 。它们在 <code>etc</code> 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。<br>我们可以简单地使用下面命令直接添加内容到 <code>.zshrc</code>中：</p><pre><code>$ echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</code></pre><p>上述命令中 <code>&gt;&gt;</code>表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 <code>&gt;</code> 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。</p><p>&emsp;</p><h3 id="变量修改"><a href="#变量修改" class="headerlink" title="变量修改"></a>变量修改</h3><table><thead><tr><th>变量设置方式</th><th>说明</th></tr></thead><tbody><tr><td>{变量名#匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>{变量名##匹配字串}</td><td>从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>{变量名%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td>{变量名%%匹配字串}</td><td>从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td>{变量名/旧的字串/新的字串}</td><td>将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td>{变量名//旧的字串/新的字串}</td><td>将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><p>&emsp;</p><h3 id="变量删除-使用-unset-命令删除一个环境变量："><a href="#变量删除-使用-unset-命令删除一个环境变量：" class="headerlink" title="变量删除,使用 unset 命令删除一个环境变量："></a>变量删除,使用 unset 命令删除一个环境变量：</h3><pre><code>$ unset temp</code></pre><p>&emsp;</p><h3 id="让环境变量立即生效"><a href="#让环境变量立即生效" class="headerlink" title="让环境变量立即生效"></a>让环境变量立即生效</h3><p>我们在 Shell 中修改了一个配置脚本文件之后（比如 <code>zsh</code> 的配置文件 home 目录下的 <code>.zshrc</code>），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用<code>source</code> 命令来让其立即生效，如：</p><pre><code>$ source .zshrc</code></pre><p>source 命令还有一个别名就是 .，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成 . 的方式就该是：</p><pre><code>$ . ./.zshrc</code></pre><p><strong>注意:</strong>第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。</p><p>&emsp;</p><h2 id="七、搜索文件"><a href="#七、搜索文件" class="headerlink" title="七、搜索文件"></a>七、搜索文件</h2><ul><li><p><code>whereis &lt;&gt;</code><br>这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。</p></li><li><p><code>locate &lt;&gt;</code><br>通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令。</p><pre><code>$ sudo apt-get install locate</code></pre><p>$ locate /etc/sh</p></li></ul><p><strong>注意，</strong>它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。</p><pre><code>$ locate /usr/share/\*.jpg</code></pre><p><strong>*注意</strong>要添加 * 号前面的反斜杠转义，否则会无法找到。<br>如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用</p><p>&emsp;</p><ul><li><p><code>which &lt;&gt;</code><br>which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令</p></li><li><p><code>find &lt;&gt;</code></p></li><li><p>find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。<br>千万记住 find 的第一个参数是要搜索的地方,基本命令格式为 find [path] [option] [action] 。</p><pre><code>$ sudo find /etc/ -name interfaces</code></pre><table><thead><tr><th>参数</th><th align="center">说明</th></tr></thead><tbody><tr><td>-atime</td><td align="center">最后访问时间</td></tr><tr><td>-ctime</td><td align="center">最后修改文件<strong>内容</strong>的时间</td></tr><tr><td>-mtime</td><td align="center">最后修改文件<strong>属性</strong>的时间</td></tr></tbody></table></li></ul><ul><li><code>mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li><li><code>mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li><li><code>mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li><li><code>newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li></ul><p>&emsp;<br><img src="http://img0.ph.126.net/ljimcqGdyrRNISeVp9Szww==/6597788847263495358.png" alt="05"></p><p>&emsp;<br>列出 home 目录中，当天（24 小时之内）有改动的文件：</p><pre><code>$ find ~ -mtime 0</code></pre><p>&emsp;</p><ul><li><p>黑客帝国特效：</p><pre><code>$ sudo apt-get update;sudo apt-get install cmatrix</code></pre><p>$ cmatrix</p></li></ul><p>&emsp;</p><h2 id="八、解压缩文件"><a href="#八、解压缩文件" class="headerlink" title="八、解压缩文件"></a>八、解压缩文件</h2><h3 id="使用-zip-打包文件夹："><a href="#使用-zip-打包文件夹：" class="headerlink" title="使用 zip 打包文件夹："></a>使用 zip <strong>打包</strong>文件夹：</h3><pre><code>$ cd /home/shiyanlou</code></pre><p>$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop<br>$ du -h shiyanlou.zip<br>$ file shiyanlou.zip</p><ul><li>上面命令将目录 /home/shiyanlou/Desktop 打包成一个文件，并查看了打包后文件的大小和类型。第一行命令中，<code>-r</code> 参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示为安静模式，即不向屏幕输出信息，<code>-o</code>，表示输出文件，需在其后紧跟打包输出文件名。后面使用 <code>du</code> 命令查看打包后文件的大小</li></ul><p>&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br><span class="line">$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br></pre></td></tr></table></figure><ul><li>这里添加了一个参数用于设置压缩级别 -[1-9]，<strong>1 表示最快压缩但体积大，9 表示体积最小但耗时最久。</strong>最后那个 <code>-x</code> 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，体积就大了。<strong>注意：这里只能使用绝对路径，否则不起作用。</strong></li></ul><p>&emsp;</p><pre><code>$ du -h -d 0 *.zip ~ | sort</code></pre><ul><li>我们再用 du 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小</li><li>h， –human-readable</li><li>d， –max-depth（所查看文件的深度）</li></ul><p>&emsp;</p><h3 id="使用-e参数可以创建加密压缩包："><a href="#使用-e参数可以创建加密压缩包：" class="headerlink" title="使用 -e参数可以创建加密压缩包："></a>使用 <code>-e</code>参数可以创建加密压缩包：</h3><pre><code>$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop</code></pre><ul><li><p><strong>注意</strong>：在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：</p><p>$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop<br>需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。</p></li></ul><p>&emsp;</p><h3 id="zip-解压"><a href="#zip-解压" class="headerlink" title="zip 解压"></a>zip 解压</h3><ul><li><p>将 shiyanlou.zip 解压到当前目录：</p><pre><code>$ unzip shiyanlou.zip</code></pre></li><li><p>使用安静模式，将文件解压到指定目录(指定路径：<code>-d</code> 参数)：</p><pre><code>$ unzip -q shiyanlou.zip -d ziptest</code></pre></li><li><p>不想解压只想查看压缩包的内容你可以使用 <code>-l</code>参数：</p><pre><code>$ unzip -l shiyanlou.zip</code></pre></li></ul><p>&emsp;</p><ul><li><p>通常<code>Windows</code>系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 <code>GBK</code>或其它编码，而 <code>Linux</code>上面默认使用的是<code>UTF-8</code> 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。<br>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型:</p><pre><code>unzip -O GBK 中文压缩文件.zip</code></pre></li></ul><p>&emsp;</p><h3 id="tar打包解包"><a href="#tar打包解包" class="headerlink" title="tar打包解包"></a>tar打包解包</h3><ul><li><p>即不进行压缩只是进行打包（创建归档文件）和解包的操作。</p></li><li><p>创建一个 tar 包：</p><p>$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop<br><code>-c</code>表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后，比如不能写成 <code>tar -fc shiyanlou.tar</code>，可以写成 <code>tar -f shiyanlou.tar -c ~</code>。你还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的 <code>/</code>，你也可以使用 <code>-P</code>保留绝对路径符。</p></li></ul><p>&emsp;</p><h3 id="解包一个文件（-x参数）到指定路径的已存在目录-（指定路径：-C-参数）"><a href="#解包一个文件（-x参数）到指定路径的已存在目录-（指定路径：-C-参数）" class="headerlink" title="解包一个文件（-x参数）到指定路径的已存在目录:（指定路径：-C 参数）"></a>解包一个文件（<code>-x</code>参数）到指定路径的已存在<strong>目录</strong>:（指定路径：<code>-C</code> 参数）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf shiyanlou.tar -C tardir</span><br><span class="line">只查看不解包文件 `-t` 参数：</span><br><span class="line"></span><br><span class="line">$ tar -tf shiyanlou.tar</span><br><span class="line">保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar </span><br><span class="line">备份文件当你在其他主机还原时希望保留文件的属性（`-p` 参数）</span><br><span class="line">和备份链接指向的源文件而不是链接本身（`-h` 参数）：</span><br><span class="line">    </span><br><span class="line">$ tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure><h3 id="对于创建不同的压缩格式的文件，对于-tar-来说是相当简单的，需要的只是换一个参数"><a href="#对于创建不同的压缩格式的文件，对于-tar-来说是相当简单的，需要的只是换一个参数" class="headerlink" title="对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数"></a>对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数</h3><ul><li><p>我们只需要在创建 tar 文件的基础上添加 <code>-z</code>参数，使用 <code>gzip</code> 来压缩文件：</p><p>$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop</p></li><li><p>解压 *.tar.gz 文件：</p><p>$ tar -xzf shiyanlou.tar.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|压缩文件格式|参数|</span><br><span class="line">|---|---|</span><br><span class="line">|*.tar.gz|-z|</span><br><span class="line">|*.tar.xz|-J|</span><br><span class="line">|*.tar.bz2|-j|</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;</p><h3 id="火炉福利："><a href="#火炉福利：" class="headerlink" title="火炉福利："></a>火炉福利：</h3><pre><code>$ sudo apt-get install libaa-bin </code></pre><p>$ aafire</p><p>&emsp;</p><h2 id="九、开虚拟硬盘知识"><a href="#九、开虚拟硬盘知识" class="headerlink" title="九、开虚拟硬盘知识"></a>九、开虚拟硬盘知识</h2><h3 id="使用-df-du-命令查看磁盘的容量"><a href="#使用-df-du-命令查看磁盘的容量" class="headerlink" title="使用 df, du 命令查看磁盘的容量"></a>使用 <code>df</code>, <code>du</code> 命令查看磁盘的容量</h3><ul><li><p>看得懂的方式：</p><pre><code>$ df -h</code></pre><p>至于挂载点如果你还记得前面第 4 节介绍 Linux 目录树结构的内容，那么你就应该能很好的理解挂载的概念</p></li><li><p>使用 du 命令查看目录的容量<br>加上<code>-h</code>参数，以更易读的方式展示</p></li><li><p>-d参数指定查看目录的深度</p><pre><code>$ du -h -d 0 ~     # 只查看1级目录的信息</code></pre><p>$ du -h -d 1 ~ # 查看2级<br><code>du -h</code> #同–human-readable 以K，M，G为单位，提高信息的可读性。<br><code>du -a</code>#同–all 显示目录中所有文件的大小。<br><code>du -s</code> #同–summarize 仅显示总计，只列出最后加总的值。</p></li></ul><p>&emsp;</p><h3 id="命令-dd"><a href="#命令-dd" class="headerlink" title="命令 dd"></a>命令 <code>dd</code></h3><ul><li>dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，<strong>一切即文件</strong>，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能。<br>&emsp;</li><li>dd 也可以读取文件或写入这些文件。这样，<strong>dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中</strong>。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。<br>&emsp;</li><li>dd默认从标准输入中读取，并写入到标准输出中，但可以用选项<code>if</code>（input file，输入文件）和<code>of</code>（output file，输出文件）改变。</li></ul><p>&emsp;</p><pre><code>$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1</code></pre><p># 输出到标准输出<br>$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1<br># 注在打完了这个命令后，继续在终端打字，作为你的输入</p><ul><li><p>上述命令从<strong>标准输入设备读入用户输入（缺省值，所以可省略）</strong>然后输出到 test 文件，<code>bs</code>（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），<code>count</code>用于指定块数量。</p><pre><code>$ du -b test        #显示大小 </code></pre><p>$ cat test #显示内容</p></li></ul><p>&emsp;</p><ul><li>内黑底百分号表示这里没有换行符,而其他的多余输入将被截取并保留在标准输入。</li></ul><p>将输出的英文字符转换为大写再写入文：</p><pre><code>$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</code></pre><p>&emsp;</p><h3 id="虚拟磁盘"><a href="#虚拟磁盘" class="headerlink" title="虚拟磁盘"></a>虚拟磁盘</h3><ul><li><p>虚拟磁盘的第一步。<br>从/dev/zero设备创建一个容量为 256M 的空文件：</p><pre><code>$ dd if=/dev/zero of=virtual.img bs=1M count=256</code></pre><p>$ du -h virtual.img</p></li><li><p>使用 <code>mkfs</code> 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）<br>在命令行输入 <code>sudo mkfs</code> 然后按下<code>Tab</code>键，你可以看到很多个以 <code>mkfs</code> 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，<br>虚拟磁盘镜像格式化为ext4文件系统：</p><pre><code>$ sudo mkfs.ext4 virtual.img</code></pre></li></ul><p>&emsp;</p><ul><li><p>如果想知道 Linux 支持哪些文件系统你可以输入:</p><pre><code>$ ls -l /lib/modules/$(uname -r)/kernel/fs</code></pre></li></ul><p>&emsp;</p><h3 id="命令-mount"><a href="#命令-mount" class="headerlink" title="命令 mount"></a>命令 <code>mount</code></h3><ul><li><p>使用 mount 命令挂载磁盘到目录树<br>Linux/UNIX 命令行的 <code>mount</code> 指令是告诉操作系统，对应的<strong>文件系统</strong>已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p></li><li><p>使用mount来查看下主机已经挂载的文件系统:</p><pre><code>$ sudo mount</code></pre></li><li><p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p></li><li><p>mount [<code>-o</code>[操作选项]] [<code>-t</code>文件系统类型] [<code>-w</code>|<code>--rw</code>|<code>--ro</code>] [文件系统源] [挂载点]</p></li><li><p>现在直接来挂载我们创建的虚拟磁盘镜像到/mnt目录：</p><pre><code>$ mount -o loop -t ext4 virtual.img /mnt </code></pre><p>/# 也可以省略挂载类型，很多时候 mount 会自动识别<br>/# 以只读方式挂载<br>$ mount -o loop –ro virtual.img /mnt</p><pre><code>/# 或者mount -o loop,ro virtual.img /mnt</code></pre></li></ul><p>&emsp;</p><h3 id="使用-fdisk为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）"><a href="#使用-fdisk为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）" class="headerlink" title="使用 fdisk为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）"></a>使用 <code>fdisk</code>为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）</h3><pre><code># 查看硬盘分区表信息
$ sudo fdisk -l</code></pre><p># 进入磁盘分区模式<br>$ sudo fdisk virtual.img<br><img src="http://img0.ph.126.net/_bugrqHB8nLWj-BoT6WfpA==/6597355639682421876.png" alt="06"></p><ul><li><p>在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区(img1)剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区(img5)(img6)。</p></li><li><p>操作完成后输入<code>p</code>查看结果.<br><img src="http://img1.ph.126.net/WjrE9zvTkcCeftcLjp8veg==/6597950475472775317.png" alt="07"><br>最后不要忘记输入<code>w</code>写入分区表。</p></li></ul><p>&emsp;</p><h3 id="使用-losetup-命令建立镜像与回环设备的关联"><a href="#使用-losetup-命令建立镜像与回环设备的关联" class="headerlink" title="使用 losetup 命令建立镜像与回环设备的关联"></a>使用 <code>losetup</code> 命令建立镜像与回环设备的关联</h3><pre><code>$ sudo losetup /dev/loop0 virtual.img</code></pre><p># 如果提示设备忙你也可以使用其它的回环设备，”ls /dev/loop*”参看所有回环设备<br># 解除设备关联<br>$ sudo losetup -d /dev/loop0</p><h3 id="格式化-mkfs"><a href="#格式化-mkfs" class="headerlink" title="格式化 mkfs"></a>格式化 <code>mkfs</code></h3><ul><li><p>然后再使用<code>mkfs</code>格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到<code>kpartx</code>工具，需要先安装：</p><pre><code>$ sudo apt-get install kpartx</code></pre><p>$ sudo kpartx -av /dev/loop0</p><pre><code>\# 取消映射
$ sudo kpartx -dv /dev/loop0</code></pre><p><img src="http://img0.ph.126.net/k74y3J3Gfh6arK7VbqUKbA==/6597904295984410230.png" alt="08"></p></li></ul><h3 id="接着再是格式化，我们将其全部格式化为-ext4："><a href="#接着再是格式化，我们将其全部格式化为-ext4：" class="headerlink" title="接着再是格式化，我们将其全部格式化为 ext4："></a>接着再是格式化，我们将其全部格式化为 <code>ext4</code>：</h3><pre><code>$ sudo mkfs.ext4 -q /dev/mapper/loop0p1</code></pre><p>$ sudo mkfs.ext4 -q /dev/mapper/loop0p5<br>$ sudo mkfs.ext4 -q /dev/mapper/loop0p6</p><h3 id="格式化完成后在-media目录下新建四个空目录用于挂载虚拟磁盘："><a href="#格式化完成后在-media目录下新建四个空目录用于挂载虚拟磁盘：" class="headerlink" title="格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘："></a>格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：</h3><pre><code>$ mkdir -p /media/virtualdisk_{1..3}

\# 挂载磁盘分区
$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1</code></pre><p>$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2<br>$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3</p><pre><code>\# 卸载磁盘分区
$ sudo umount /dev/mapper/loop0p1</code></pre><p>$ sudo umount /dev/mapper/loop0p5<br>$ sudo umount /dev/mapper/loop0p6</p><p>&emsp;</p><ul><li>查看一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://img2.ph.126.net/ZggXQbSGyoaZfQSp-pyiIw==/2962242655003414793.png" alt="09"></p><p>&emsp;</p><h3 id="动物福利"><a href="#动物福利" class="headerlink" title="动物福利"></a>动物福利</h3><pre><code># 更新软件包
$ sudo apt-get update</code></pre><p>$ sudo apt-get install npm</p><pre><code>\# 安装
$ sudo npm install -g cowsay

\# 默认是一只牛
$ cowsay hello shiyanlou

\# 加上&apos;-l&apos;参数打印所有支持的动物（其实不只是动物）种类
$ cowsay -l

\# 使用&apos;-f&apos;参数选择动物种类
$ cowsay -f elephant hello shiyanlou

\# 安装 fortune-zh
$ sudo apt-get install fortune-zh

\# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用
$ /usr/games/fortune | cowsay -f daemon

$ cowsay &lt;随便输入&gt;</code></pre><p>&emsp;</p><h2 id="十、帮助命令"><a href="#十、帮助命令" class="headerlink" title="十、帮助命令"></a>十、帮助命令</h2><ul><li><p>内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，<strong>通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快</strong>。比如：history、cd、exit 等等。</p></li><li><p>外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，<strong>在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。</strong>虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。</p><pre><code>\# type 命令来区分命令是内建的还是外部的
$ type &lt;&gt;</code></pre></li><li><p><code>help &lt;&gt;</code>命令用于显示内建命令的帮助信息</p></li><li><p><code>&lt;&gt; --help</code> 命令用于显示外建命令的帮助信息</p></li><li><p><code>man &lt;&gt;</code>　没有内建与外部命令的区分，内容比用 help 更多更详细</p></li></ul><p>&emsp;</p><ul><li>最左上角显示“ LS （?）,“ LS ”表示手册名称，而“（?）”表示该手册位于第几章节,通过 <code>pgup</code> 与 <code>pgdn</code>或者上下键来上下翻看（我的好像要加上Shift）<br><img src="http://img0.ph.126.net/Fr-SPPYhl7GC0GdRSWErsQ==/6597977963263463937.png" alt="10"></li><li><code>info &lt;&gt;</code> 比 man 还要多了</li></ul><p>&emsp;</p><h2 id="十一、任务计划crontab"><a href="#十一、任务计划crontab" class="headerlink" title="十一、任务计划crontab"></a>十一、任务计划crontab</h2><ul><li><p><code>crontab</code>命令<br>从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p></li><li><p>格式<br><img src="http://img0.ph.126.net/wEE3VQpZ-xyI1LhmIfBG-A==/6608205620425250688.png" alt="11"></p></li><li><p>启动 <code>rsyslog</code>，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了<br>在自己本地中 Ubuntu 会默认自行启动不需要手动启动</p><pre><code>sudo apt-get install -y rsyslog
sudo service rsyslog start</code></pre><p>手动启动:</p><pre><code>sudo cron －f &amp;</code></pre></li><li><p>我们通过下面一个命令来添加一个计划任务</p><pre><code>crontab -e 表示为当前用户添加计划任务
sudo crontab -e 表示为root用户添加计划任务</code></pre><p>然后选择第二个基本的 vim。<br>在文档的最后一排加上这样一排命令,该任务是每分钟我们会在/home/shiyanlou目录下创建一个以当前的年月日时分秒为名字的空白文件。</p><pre><code>*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code></pre></li></ul><p><strong>注意</strong> <code>“ % ”</code> 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 <code>” \ ”</code> 符号转义，否则，<code>“ % ”</code> 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p><p>保存： &lt;<code>:wp</code>&gt;</p><ul><li><p>查看我们添加了哪些任务</p><pre><code>crontab -l </code></pre></li><li><p>以下2种方式来确定我们的 cron 是否成功的在后台启动</p><pre><code>ps aux | grep cron
or
pgrep cron</code></pre></li><li><p>后续在每分钟的01秒时执行一次我们的任务,显示使用命令</p><pre><code>$ ll</code></pre></li><li><p>我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈</p><pre><code>sudo tail -f /var/log/syslog</code></pre></li><li><p>删除任务</p><pre><code>crontab -r</code></pre></li><li><p>每个用户使用 <code>crontab -e</code> 添加计划任务，都会在 /var/spool/cron/crontabs 中添加一个该用户自己的任务文档，这样目的是为了隔离。</p></li><li><p>如果是系统级别的定时任务，只需要以 sudo 权限编辑 /etc/crontab 文件就可以。</p></li><li><p>cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。</p></li><li><p>在 /etc 目录下，cron 相关的目录有下面几个：</p><pre><code>$ ll /etc/ |grep cron</code></pre><p>每个目录的作用：<br><code>/etc/cron.daily</code>，目录下的脚本会每天执行一次，在每天的6点25分时运行；<br><code>/etc/cron.hourly</code>，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；<br><code>/etc/cron.monthly</code>，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；<br><code>/etc/cron.weekly</code>，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；</p></li></ul><p>系统默认执行时间可以根据需求进行修改。</p><p>&emsp;</p><h2 id="十二、顺序执行多条命令、管道"><a href="#十二、顺序执行多条命令、管道" class="headerlink" title="十二、顺序执行多条命令、管道"></a>十二、顺序执行多条命令、管道</h2><ul><li><p>一次性输入完，让它自己去依次执行各命令</p><pre><code>$ sudo apt-get update;sudo apt-get install some-tool;some-tool</code></pre></li><li><p>使用<code>which</code>来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做</p><pre><code>$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</code></pre></li></ul><p>上面的<code>&amp;&amp;</code>就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从<code>$?</code>环境变量获取上一次命令的返回结果：</p><pre><code>    $ which cossay
$ echo $? </code></pre><p><strong>注意</strong>：搭配使用</p><p>&emsp;</p><ul><li><p><code>||</code>在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：</p><pre><code>$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&quot;</code></pre></li><li><p>是0，执行<code>&amp;&amp;</code>；非0，执行<code>||</code></p></li></ul><pre><code>$ which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code></pre><ul><li><p>管道<br>管道是一种通信机制，通常用于进程间的通信（也可通过<code>socket</code>进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</p><p>有太多内容，屏幕不能完全显示</p><pre><code>$ ls -al /etc | less</code></pre><p>通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。</p></li><li><p><code>cut</code> 命令，打印每一行的某一字段<br>打印/etc/passwd文件中以<code>:</code>为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：</p><pre><code>$ cut /etc/passwd -d &apos;:&apos; -f 1,6</code></pre><p>打印/etc/passwd文件中每一行的前N个字符：</p><pre><code>\# 前五个（包含第五个）
$ cut /etc/passwd -c -5</code></pre><p># 前五个之后的（包含第五个）<br>$ cut /etc/passwd -c 5-</p><pre><code>\# 第五个
$ cut /etc/passwd -c 5</code></pre><p># 2到5之间的（包含第五个）<br>$ cut /etc/passwd -c 2-5</p></li><li><p><code>grep</code> 命令，在文本中或 stdin 中查找匹配字符串</p><p>grep命令的一般形式为：</p><pre><code>grep [命令选项]... 用于匹配的表达式 [文件]...</code></pre><p>我们搜索/home/shiyanlou目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：</p><pre><code>$ grep -rnI &quot;shiyanlou&quot; ~</code></pre><p><code>-r</code> 参数表示递归搜索子目录中的文件,<code>-n</code>表示打印匹配项行号，<code>-I</code>表示忽略二进制文件。</p></li><li><p>当然也可以在匹配字段中使用正则表达式</p><pre><code># 查看环境变量中以&quot;yanlou&quot;结尾的字符串
$ export | grep &quot;.*yanlou$&quot;</code></pre><p>其中<code>$</code>就表示一行的末尾。</p></li><li><p><code>wc</code> 命令，简单小巧的计数工具<br>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：</p><pre><code>$ wc /etc/passwd</code></pre><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p><pre><code># 行数
$ wc -l /etc/passwd</code></pre><p># 单词数<br>$ wc -w /etc/passwd</p><pre><code>\# 字节数
$ wc -c /etc/passwd</code></pre><p># 字符数<br>$ wc -m /etc/passwd</p><pre><code>\# 最长行字节数
$ wc -L /etc/passwd</code></pre></li></ul><p><strong>注意</strong>：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的</p><p>&emsp;</p><ul><li><p>下面统计 /etc 下面所有目录数：</p><pre><code>$ ls -dl /etc/*/ | wc -l    </code></pre></li><li><p><code>sort</code> 排序命令<br>默认为字典排序：</p><pre><code>$ cat /etc/passwd | sort</code></pre><p>反转排序：</p><pre><code>$ cat /etc/passwd | sort -r</code></pre><p>按特定字段排序：</p><pre><code>$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</code></pre></li><li><p>上面的<code>-t</code>参数用于指定字段的分隔符，这里是以<code>&quot;:&quot;</code>作为分隔符；<code>-k</code> 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数：</p><pre><code>$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n</code></pre></li><li><p><code>uniq</code> 去重命令<br>过滤重复行</p><pre><code>使用history命令查看最近执行过的命令

$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq</code></pre><p>只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p><pre><code>$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq</code></pre><p># 或者$ history | cut -c 8- | cut -d ‘ ‘ -f 1 | sort -u</p><p>输出重复的行</p><pre><code>\# 输出重复过的行（重复的只输出一个）及重复次数
$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc</code></pre><p># 输出所有重复的行<br>$ history | cut -c 8- | cut -d ‘ ‘ -f 1 | sort | uniq -D</p></li><li><p>代码显示图片<br>安装<code>aview</code>和<code>imagemagick</code>，然后用<code>asciiview</code>命令显示图片，使用方法可以用 man 命令查看。</p></li><li><p><code>tr</code> 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p><pre><code>tr [option]...SET1 [SET2]</code></pre></li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td>-s</td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><pre><code>    操作举例：

\# 删除 &quot;hello shiyanlou&quot; 中所有的&apos;o&apos;,&apos;l&apos;,&apos;h&apos;
$ echo &apos;hello shiyanlou&apos; | tr -d &apos;olh&apos;</code></pre><p># 将”hello” 中的ll,去重为一个l<br>$ echo ‘hello’ | tr -s ‘l’<br># 将输入文本，全部转换为大写输出<br>$ echo ‘input some text here’ | tr ‘[:lower:]’ ‘[:upper:]’<br># 上面的’[:lower:]’ ‘[:upper:]’你也可以简单的写作’[a-z]’ ‘[A-Z]’,当然反过来将大写变小写也是可以的</p><ul><li><code>col</code> 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-x</td><td>将Tab转换为空格</td></tr><tr><td>-h</td><td>将空格转换为Tab（默认选项）</td></tr></tbody></table><pre><code>\# 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号
$ cat -A /etc/protocols 看到文本中包含的不可见特殊字符</code></pre><p># 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了<br>$ cat /etc/protocols | col -x | cat -A</p><ul><li><p>这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。</p><pre><code>join [option]... file1 file2</code></pre></li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定分隔符，默认为空格</td></tr><tr><td>-i</td><td>忽略大小写的差异</td></tr><tr><td>-1</td><td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td>-2</td><td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><pre><code>    操作举例：

\# 创建两个文件
$ echo &apos;1 hello&apos; &gt; file1</code></pre><p>$ echo ‘1 shiyanlou’ &gt; file2<br>$ join file1 file2<br># 将/etc/passwd与/etc/shadow两个文件合并，指定以’:’作为分隔符<br>$ sudo join -t’:’ /etc/passwd /etc/shadow<br># 将/etc/passwd与/etc/group两个文件合并，指定以’:’作为分隔符, 分别比对第4和第3个字段<br>$ sudo join -t’:’ -1 4 /etc/passwd -2 3 /etc/group</p><ul><li><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p><pre><code>paste [option] file...</code></pre></li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>指定合并的分隔符，默认为Tab</td></tr><tr><td>-s</td><td>不合并到一行，每个文件为一行</td></tr></tbody></table><pre><code>$ echo hello &gt; file1</code></pre><p>$ echo shiyanlou &gt; file2<br>$ echo <a href="http://www.shiyanlou.com" target="_blank" rel="noopener">www.shiyanlou.com</a> &gt; file3<br>$ paste -d ‘:’ file1 file2 file3<br>$ paste -s file1 file2 file3</p><ul><li><p>小蜜蜂游戏</p><pre><code>$ sudo apt-get install ninvaders</code></pre><p>$ /usr/games/ninvaders</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat data1 | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc | sort -k1 -n -r | head -3 &gt; /home/result</span><br></pre></td></tr></table></figure><p>第一个 <code>sort</code> 是为 <code>uniq</code> 做准备，第二个是以重复次数从大到小排列， <code>head -3</code> 是只写前三。</p><p>&emsp;</p><h2 id="十三、重定向"><a href="#十三、重定向" class="headerlink" title="十三、重定向"></a>十三、重定向</h2><table><thead><tr><th>文件描述符</th><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>/dev/stdin</td><td>标准输入</td></tr><tr><td>1</td><td>/dev/stdout</td><td>标准输出</td></tr><tr><td>2</td><td>/dev/stderr</td><td>标准错误</td></tr><tr><td>文件描述符：是一个索引值，指向<strong>内核</strong>为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</td><td></td><td></td></tr></tbody></table><ul><li>默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir Documents</span><br><span class="line">$ cat &gt; Documents/test.c &lt;&lt;EOF</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p>将一个文件作为命令的输入，标准输出作为命令的输出</p><pre><code>$ cat Documents/test.c</code></pre><ul><li><p>将<code>echo</code>命令通过管道传过来的数据作为<code>cat</code>命令的输入，将标准输出作为命令的输出</p><pre><code>$ echo &apos;hi&apos; | cat</code></pre><p>将echo命令的输出从默认的标准输出重定向到一个普通文件</p><pre><code>$ echo &apos;hello shiyanlou&apos; &gt; redirect</code></pre><p>$ cat redirect</p></li><li><p>标准错误重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</span><br><span class="line">$ cat Documents/test.c hello.c</span><br><span class="line"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</span><br><span class="line"># 下面我们将输出重定向到一个文件</span><br><span class="line">$ cat Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure></li></ul><p>有的时候我们就是要隐藏某些错误或者警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</span><br><span class="line">$ cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1</span><br><span class="line"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</span><br><span class="line">$ cat Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure><p><strong>注意你应该在输出重定向文件描述符前加上<code>&amp;</code>,否则shell会当做重定向到一个文件名为<code>1</code>的文件中</strong>，这里所用的就是文件描述符。</p><pre><code>$ cat somefile  #查看</code></pre><ul><li><p>除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用<code>tee</code>命令来实现：</p><pre><code>$ echo &apos;hello shiyanlou&apos; | tee hello</code></pre><p>$ cat hello #查看</p></li><li><p>永久重定向</p></li></ul><p>前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛，当然不需要，我们可以使用<code>exec</code>命令实现“永久”重定向。<code>exec</code>命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先开启一个子 Shell</span><br><span class="line">$ zsh</span><br><span class="line"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span><br><span class="line">$ exec 1&gt;somefile</span><br><span class="line"># 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</span><br><span class="line">$ ls</span><br><span class="line">$ exit</span><br><span class="line">$ cat somefile</span><br></pre></td></tr></table></figure><ul><li>创建输出文件描述符</li></ul><p>使用下面命令查看当前 Shell 进程中打开的文件描述符：</p><pre><code>$ cd /dev/fd/;ls -Al</code></pre><p>同样使用exec命令可以创建新的文件描述符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ zsh</span><br><span class="line">$ exec 3&gt;somefile</span><br><span class="line"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</span><br><span class="line">$ cd /dev/fd/;ls -Al;cd -</span><br><span class="line"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</span><br><span class="line">$ echo &quot;this is test&quot; &gt;&amp;3</span><br><span class="line">$ cat somefile</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure><ul><li><p>如上面我们打开的3号文件描述符，可以使用如下操作将它关闭：</p><pre><code>$ exec 3&gt;&amp;-</code></pre><p>$ cd /dev/fd;ls -Al;cd -</p></li><li><p>完全屏蔽命令的输出</p></li></ul><p>在类 UNIX 系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个<code>EOF</code>。</p><p>我们可以利用设个/dev/null屏蔽命令的输出：</p><pre><code>$ cat Documents/test.c nefile 1&gt;/dev/null 2&gt;&amp;1</code></pre><p>上面这样的操作将使你得不到任何输出结果。</p><ul><li>使用 <code>xargs</code>分割参数列表</li></ul><p>它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p><pre><code>$ cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</code></pre><p>上面这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表。</p><ul><li>图片转换为彩色 ascii 字符查看福利<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install caca-utils</span><br><span class="line">$ cacaview &lt;pic_file&gt;</span><br><span class="line">$ cacademo</span><br><span class="line">$ cacafire</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;</p><h2 id="十四、正则表达式"><a href="#十四、正则表达式" class="headerlink" title="十四、正则表达式"></a>十四、正则表达式</h2><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p><ul><li>例子</li></ul><p>假设我们有这样一个文本文件，包含”shiyanlou”，和”shilouyan”这两个字符串，同样一个表达式：</p><pre><code>shi*</code></pre><p>在正则表达式中<code>*</code>表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，比如它可以匹配”sh”,”shii”,”shish”,”shiishi”等等，而作为通配符表示匹配通配符后面任意多个任意字符，所以它可以匹配”shiyanlou”，和”shilouyan”两个字符。</p><ul><li><code>|</code>竖直分隔符表示<strong>选择</strong>，例如”boy|girl”可以匹配”boy”或者”girl”</li><li><strong>数量限定</strong>除了我们举例用的<code>*</code>,还有<code>+</code>加号,<code>?</code>问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：</li></ul><pre><code>1. `+`表示前面的字符必须出现至少一次(1次或多次)，例如，&quot;goo+gle&quot;,可以匹配&quot;gooogle&quot;,&quot;goooogle&quot;等；
2. `?`表示前面的字符最多出现一次(0次或1次)，例如，&quot;colou?r&quot;,可以匹配&quot;color&quot;或者&quot;colour&quot;;
3. `*`星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“0*42”可以匹配42、042、0042、00042等。</code></pre><ul><li><p>范围和优先级<br><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，”gr(a|e)y”等价于”gray|grey”，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），”(grand)?father”匹配father和grandfather（这里体验了范围，<code>?</code>将圆括号内容作为一个整体匹配）。</p></li><li><p>语法<br>下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符)</p></li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>＼</td><td>将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“＼\”匹配“\”而“＼(”则匹配“(”。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>*</td><td>匹配前面的子表达式<strong>零次或多次</strong>。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式<strong>一次或多次</strong>。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>？</td><td>匹配前面的子表达式<strong>零次或一次</strong>。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>？</td><td>当该字符紧跟在任何一个其他限制符（<em>,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而*</em>默认的贪婪模式**则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td></tr><tr><td>.</td><td>匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“＼(”或“＼)”。</td></tr><tr><td>x｜y</td><td>匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符<code>^</code>如果出现在首位则表示<strong>负值字符</strong>集合；如果出现在字符串中间就仅作为普通字符。连字符<code>-</code> 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</td></tr><tr><td>[^xyz]</td><td>排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td>排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr></tbody></table><ul><li>优先级为从上到下从左到右，依次降低：</li></ul><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>＼</td><td>转义符</td></tr><tr><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td>｜</td><td>选择</td></tr></tbody></table><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><ul><li><code>grep</code>命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎:</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>POSIX扩展正则表达式，ERE</td></tr><tr><td>-G</td><td>POSIX基本正则表达式，BRE</td></tr><tr><td>-P</td><td>Perl正则表达式，PCRE</td></tr></tbody></table><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>将二进制文件作为文本来进行匹配</td></tr><tr><td>-c</td><td>统计以模式匹配的数目</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示匹配文本所在行的行号</td></tr><tr><td>-v</td><td>反选，输出不匹配行的内容</td></tr><tr><td>-r</td><td>递归匹配查找</td></tr><tr><td>-A n</td><td>n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td>-B n</td><td>n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td>–color=auto</td><td>将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><p><img src="http://img1.ph.126.net/RsXISHrTmJw6SdEXIEoUfw==/2589851260735125175.png" alt="12"></p><ul><li>使用基本正则表达式，BRE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查找/etc/group文件中以&quot;shiyanlou&quot;为开头的行:</span><br><span class="line">$ grep &apos;shiyanlou&apos; /etc/group</span><br><span class="line">$ grep &apos;^shiyanlou&apos; /etc/group</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾的所有字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.*o&apos;</span><br><span class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾，中间包含一个任意字符的字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos;</span><br><span class="line"># 将匹配以&apos;z&apos;开头,以任意多个&apos;o&apos;结尾的字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos;</span><br></pre></td></tr></table></figure><ul><li>选择<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># grep默认是区分大小写的，这里将匹配所有的小写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[a-z]&apos;</span><br><span class="line"># 将匹配所有的数字</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[0-9]&apos;</span><br><span class="line"># 将匹配所有的数字</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:digit:]]&apos;</span><br><span class="line"># 将匹配所有的小写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:lower:]]&apos;</span><br><span class="line"># 将匹配所有的大写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:upper:]]&apos;</span><br><span class="line"># 将匹配所有的字母和数字，包括0-9,a-z,A-Z</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alnum:]]&apos;</span><br><span class="line"># 将匹配所有的字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alpha:]]&apos;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>特殊符号</th><th>说明</th></tr></thead><tbody><tr><td>[:blank:]</td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等</td></tr><tr><td>[:graph:]</td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td>[:print:]</td><td>代表任何可以被列印出来的字符</td></tr><tr><td>[:punct:]</td><td>代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $…</td></tr><tr><td>[:space:]</td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td>[:xdigit:]</td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><p><strong>注意</strong>：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在<strong>LANG</strong>环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，[a-z]中就可能包含大写字母。</p><ul><li>使用扩展正则表达式，ERE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 只匹配&quot;zo&quot;</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo&#123;1&#125;&apos;</span><br><span class="line"># 匹配以&quot;zo&quot;开头的所有单词</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo&#123;1,&#125;&apos;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;</span><br><span class="line">$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -E &apos;www\.(shiyanlou|google)\.com&apos;</span><br><span class="line"># 或者匹配不包含&quot;baidu&quot;的内容</span><br><span class="line">$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -Ev &apos;www\.baidu\.com&apos;</span><br></pre></td></tr></table></figure><p><strong>注意符号.的处理</strong></p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><ul><li>sed 命令基本格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br><span class="line"># 形如：</span><br><span class="line">$ sed -i &apos;s/sad/happy/&apos; test # 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td>-e</td><td>用于在<strong>脚本</strong>中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td>-f filename</td><td>指定执行filename文件中的命令</td></tr><tr><td>-r</td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td>-i</td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><ul><li>sed执行命令格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[n1][,n2]command</span><br><span class="line">[n1][~step]command</span><br><span class="line"># 其中一些命令可以在后面加上作用范围，形如：</span><br><span class="line">$ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围</span><br><span class="line">$ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串</span><br></pre></td></tr></table></figure></li></ul><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>s</td><td>行内替换</td></tr><tr><td>c</td><td>整行替换</td></tr><tr><td>a</td><td>插入到指定行的后面</td></tr><tr><td>i</td><td>插入到指定行的前面</td></tr><tr><td>p</td><td>打印指定行，通常与-n参数配合使用</td></tr><tr><td>d</td><td>删除指定行</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打印2-5行</span><br><span class="line">$ nl passwd | sed -n &apos;2,5p&apos;</span><br><span class="line"># 打印奇数行</span><br><span class="line">$ nl passwd | sed -n &apos;1~2p&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令</span><br><span class="line">$ sed -n &apos;s/shiyanlou/hehe/gp&apos; passwd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nl passwd | grep &quot;shiyanlou&quot;</span><br><span class="line"># 删除第21行</span><br><span class="line">$ sed -n &apos;21c\www.shiyanlou.com&apos; passwd</span><br><span class="line">（这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数）</span><br></pre></td></tr></table></figure><h4 id="awk文本处理语言"><a href="#awk文本处理语言" class="headerlink" title="awk文本处理语言"></a>awk文本处理语言</h4><p>它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p><p>不过我们通常可以直接使用awk命令（awk语言的解释器），因为系统已经为我们创建好了awk指向mawk的符号链接。</p><pre><code>    $ ll /usr/bin/awk
$ ll /usr/bin/mawk</code></pre><p>mawk 也是awk编程语言的一种解释器</p><p>awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p><pre><code>$ pattern {action}</code></pre><p>它将所有的动作操作用一对<code>{}</code>花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。</p><ul><li><p>awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符，下面将告诉你如何做到这一点。</p><pre><code>awk [-F fs] [-v var=value] [-f prog-file | &apos;program text&apos;] [file...]</code></pre><p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为awk程序指定变量，<code>-f</code>参数用于指定awk命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为awk需要处理的文本输入，且可以同时输入多个文本文件。</p></li><li><p>先用vim新建一个文本文档</p><pre><code>$ vim test</code></pre></li></ul><p>包含如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I like linux</span><br><span class="line">www.shiyanlou.com</span><br></pre></td></tr></table></figure><ul><li>使用awk将文本内容打印到终端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># &quot;quote&gt;&quot; 不用输入</span><br><span class="line">$ awk &apos;&#123;</span><br><span class="line">&gt; print</span><br><span class="line">&gt; &#125;&apos; test</span><br><span class="line"># 或者写到一行</span><br><span class="line">$ awk &apos;&#123;print&#125;&apos; test</span><br></pre></td></tr></table></figure></li></ul><p>说明:在这个操作中我是省略了<code>pattern</code>，所以awk会默认匹配输入文本的全部内容，然后在<code>&quot;{}&quot;</code>花括号中执行动作，即<code>print</code>打印所有匹配项，这里是全部文本内容</p><ul><li><p>将test的第一行的每个字段单独显示为一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ awk &apos;&#123;</span><br><span class="line">&gt; if(NR==1)&#123;</span><br><span class="line">&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3</span><br><span class="line">&gt; &#125; else &#123;</span><br><span class="line">&gt; print&#125;</span><br><span class="line">&gt; &#125;&apos; test</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">$ awk &apos;&#123;</span><br><span class="line">&gt; if(NR==1)&#123;</span><br><span class="line">&gt; OFS=&quot;\n&quot;</span><br><span class="line">&gt; print $1, $2, $3</span><br><span class="line">&gt; &#125; else &#123;</span><br><span class="line">&gt; print&#125;</span><br><span class="line">&gt; &#125;&apos; test</span><br></pre></td></tr></table></figure></li><li><p><code>NR</code>与<code>OFS</code>，这两个是awk内建的变量，NR表示当前读入的记录数，你可以简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为”<code></code>“空格，如上图所见，我们将字段分隔符设置为<code>\n</code>换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是<code>$N</code>其中<code>N</code>为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了<code>$3</code>。除此之外另一个这里没有出现的<code>$0</code>，它表示引用当前记录（当前行）的全部内容。</p></li><li><p>将test的第二行的以点为分段的字段换成以空格为分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F&apos;.&apos; &apos;&#123;</span><br><span class="line">&gt; if(NR==2)&#123;</span><br><span class="line">&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3</span><br><span class="line">&gt; &#125;&#125;&apos; test</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">$ awk &apos;</span><br><span class="line">&gt; BEGIN&#123;</span><br><span class="line">&gt; FS=&quot;.&quot;</span><br><span class="line">&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开  </span><br><span class="line">&gt; &#125;&#123;</span><br><span class="line">&gt; if(NR==2)&#123;</span><br><span class="line">&gt; print $1, $2, $3</span><br><span class="line">&gt; &#125;&#125;&apos; test</span><br></pre></td></tr></table></figure></li><li><p><code>-F</code>参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的<code>\t</code>，<strong>print打印的非变量内容都需要用<code>&quot;&quot;</code>一对引号包围起来</strong>。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，<strong>即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行</strong>，这里是FS赋值了新的”.”点号代替默认的” “空格。</p></li></ul><p><img src="http://img1.ph.126.net/D1BeVYb783ShEYdzJ4t8Hg==/6597311659216927555.png" alt="13"></p><pre><code>1. 在文件data中匹配数字开头的行，结果写入/home/shiyanlou/num文件

$ cat data | grep &apos;^[0-9]&apos; &gt; /home/shiyanlou/num</code></pre><p>标准：<br>$ grep ‘^[0-9]’ data &gt; /home/shiyanlou/num</p><pre><code>2. 在文件data中匹配出正确格式的邮箱，结果写入一个名为/home/shiyanlou/mail的文件

$ grep &apos;.*\@.*\.com&apos; data &gt; /home/shiyanlou/mail</code></pre><p><strong>注意：</strong> <code>.*</code> 表示任意多个字符，特殊字符前加上<code>\</code></p><ul><li>快速学会vim的基础操作：<br>vim大冒险</li></ul><p>&emsp;</p><h2 id="十五、安装命令-Ubuntu"><a href="#十五、安装命令-Ubuntu" class="headerlink" title="十五、安装命令(Ubuntu)"></a>十五、安装命令(Ubuntu)</h2><pre><code>    $ sudo apt-get install w3m
$ w3m www.shiyanlou.com/faq</code></pre><ul><li><p>注意:如果你在安装一个软件之后，无法立即使用<code>Tab</code>键补全这个命令，你可以尝试先执行source ~/.zshrc，然后你就可以使用补全操作</p></li><li><p>APT是Advance Packaging Tool（高级包装工具）的缩写，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的多个工具，如 apt-get apt-cache apt-cdrom 等，</p></li><li><p>当你在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。</p></li><li><p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，我举个例子：我们安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。</p></li><li><p>下面列出一些apt-get包含的常用的一些工具：<br><img src="http://img1.ph.126.net/iCSwYaRDp47Amk_cR6IRQA==/6631699984889391958.png" alt="14"></p></li><li><p>下面是一些apt-get常用的参数：<br><img src="http://img0.ph.126.net/WYqDlFcuNinj86L4tbC49Q==/6631699984889391978.png" alt="15"></p></li><li><p>你可以使用如下方式重新安装：</p><pre><code>$ sudo apt-get --reinstall install w3m</code></pre></li><li><p>另一个你需要掌握的是，如何在不知道软件包完整名的时候进行安装。通常我们是使用Tab键补全软件包名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 更新软件源</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"># 升级没有依赖问题的软件包</span><br><span class="line">$ sudo apt-get upgrade</span><br><span class="line"># 升级并解决依赖关系</span><br><span class="line">$ sudo apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line">#卸载</span><br><span class="line">$ sudo apt-get remove w3m</span><br><span class="line"># 或者不保留配置文件的移除</span><br><span class="line">$ sudo apt-get purge w3m</span><br><span class="line"># 或者 sudo apt-get --purge remove</span><br><span class="line"># 移除不再需要的被依赖的软件包</span><br><span class="line">$ sudo apt-get autoremove</span><br></pre></td></tr></table></figure></li><li><p>当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：</p><pre><code>sudo apt-cache search softname1 softname2 softname3……</code></pre><p><code>apt-cache</code> 命令则是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 softname1 softname2 …… 相关软件的信息。</p></li></ul><h4 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h4><ul><li><p><code>dpkg</code>本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。</p></li><li><p>我们经常可以在网络上见到以deb形式打包的软件包，就需要使用dpkg命令来安装。<br><img src="http://img1.ph.126.net/2Tz1jezEYj-5h5N47sR06g==/1496039501317487800.png" alt="16"></p></li><li><p>我们先使用apt-get加上<code>-d</code>参数只下载不安装，下载emacs编辑器的deb包，下载完成后，我们可以查看: ls /var/cache/apt/archives/目录下的内容。</p></li><li><p>然后我们将第一个deb拷贝到 /home/shiyanlou 目录下，并使用dpkg安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /var/cache/apt/archives/emacs24_24.5+16ubuntu1.1_amd64.deb ~</span><br><span class="line"># 安装之前参看deb包的信息</span><br><span class="line">$ sudo dpkg -I emacs24_24.5+16ubuntu1.1_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用dpkg安装可能会存在一些问题，因为dpkg并不能为你解决依赖关系。</p><pre><code># 使用dpkg安装
$ sudo dpkg -i emacs24_24.5+16ubuntu1.1_amd64.deb</code></pre><p>使用它的<code>-f</code>参数了，修复依赖关系的安装</p><pre><code>$ sudo apt-get update</code></pre><p>$ sudo apt-get -f install</p></li><li><p>查看已安装软件包的安装目录</p><pre><code>$ sudo dpkg -L emacs24</code></pre></li><li><p>假装电视福利</p><pre><code>$ sudo apt-get install bb</code></pre><p>$ /usr/games/bb</p></li></ul><p>&emsp;</p><h2 id="十六、进程"><a href="#十六、进程" class="headerlink" title="十六、进程"></a>十六、进程</h2><ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。<strong>它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件</strong>。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li></ul><h4 id="进程衍生"><a href="#进程衍生" class="headerlink" title="进程衍生"></a>进程衍生</h4><ul><li>就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的</li><li>于父进程与子进程便会提及这两个系统调用 <code>fork()</code> 与 <code>exec()</code>。</li><li><code>fork()</code> 是一个系统调用（system call），它的主要作用就是<strong>为当前的进程创建一个新的进程</strong>，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</li><li><code>exec()</code> 也是系统调用，作用是切换子进程中的执行程序也就是<strong>替换</strong>其从父进程复制过来的代码段与数据段</li><li>子进程就是父进程通过系统调用 <code>fork()</code>而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 <code>exec()</code>之后才会不同，而早先的 <code>fork()</code> 比较消耗资源后来进化成 <code>vfork()</code>,效率高了不少，</li></ul><h4 id="简单的实现逻辑就如下方所示"><a href="#简单的实现逻辑就如下方所示" class="headerlink" title="简单的实现逻辑就如下方所示"></a>简单的实现逻辑就如下方所示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pid_t p;</span><br><span class="line"></span><br><span class="line">p = fork();</span><br><span class="line">if (p == (pid_t) -1)</span><br><span class="line">        /* ERROR */</span><br><span class="line">else if (p == 0)</span><br><span class="line">        /* CHILD */</span><br><span class="line">else</span><br><span class="line">        /* PARENT */</span><br></pre></td></tr></table></figure><ul><li><p>当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 <code>exit(n)</code>; 或者<code>return n</code>，这里的返回值<code>n</code> 是一个信号，系统会把这个<code>SIGCHLD</code> 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p></li><li><p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块<code>（PCB）</code>仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（<strong>因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息</strong>），并没有消亡，这样的进程称之为僵尸进程（Zombie）。</p></li><li><p>正常情况下，父进程会收到两个返回值：<code>exit code</code>（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait</code>(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</p></li><li><p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。<strong>但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程</strong>。</p></li><li><p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为<strong>孤儿进程</strong>。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害</p></li><li><p><code>进程 0</code>是系统引导时创建的一个特殊进程，也称之为<code>内核初始化</code>，其最后一个动作就是调用 <code>fork()</code>创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的<code>进程 1</code>，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 通过以下的命令我们可以很明显的看到这样的结构</span><br><span class="line">  $ pstree</span><br><span class="line"># 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的</span><br><span class="line">  $ ps －fxo user,ppid,pid,pgid,command</span><br><span class="line">```      </span><br><span class="line">在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</span><br><span class="line"></span><br><span class="line">#### 进程组与 Sessions</span><br><span class="line">- 每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 `PGID`（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</span><br><span class="line">- 进程组的 `PGID` 等同于进程组的第一个成员的 `PID`，进程一般通过使用` getpgrp() `系统调用来寻找其所在组的 PGID，**领导进程可以先终结**，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</span><br><span class="line">- 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在` Session `中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，</span><br><span class="line">- Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。**每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台**，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</span><br><span class="line">- 前台（foreground）就是在终端中运行，能与你有交互的</span><br><span class="line">- 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</span><br><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### 工作管理</span><br><span class="line">- `bash`(Bourne-Again shell)支持工作控制（job control）,而 `sh`（Bourne shell）并不支持。</span><br><span class="line">- 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。</span><br><span class="line">- 我们都知道当一个进程在前台运作时我们可以用 `ctrl + c` 来终止它，但是若是在后台的话就不行了</span><br><span class="line">- 我们可以通过 `&amp; `这个符号，让我们的命令在后台中运行</span><br><span class="line"></span><br><span class="line">        ls &amp;</span><br><span class="line">        </span><br><span class="line">图中所显示的 `[1] 236`分别是该 job 的 job number 与该进程的 PID，而最后一行的` Done `表示该命令已经在后台执行完毕。</span><br><span class="line"></span><br><span class="line">- 我们还可以通过` ctrl + z`使我们的当前工作停止并丢到后台中去</span><br><span class="line">- 被停止并放置在后台的工作我们可以使用这个命令来查看</span><br><span class="line"></span><br><span class="line">        $ jobs</span><br><span class="line">其中第一列显示的为被放置后台 job 的编号，而第二列的 `＋` 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，**也就是若是有什么针对后台 job 的操作，首先对预设的 job**，`-` 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令</span><br><span class="line"></span><br><span class="line">- 我们可以通过这样的一个命令将后台的工作拿到前台来</span><br></pre></td></tr></table></figure></li></ul><p>#后面不加参数提取预设工作，加参数提取指定工作的编号</p><p>#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</p><p>#输入命令echo $SHELL就能看到环境设定的sh类型了。</p><p>#进到bin目录下ls一下就能看到本系统能支持哪些类型的shell。</p><p>#使用export SHELL=bash可以暂时更改本机的sh类型<br>fg [%jobnumber]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 删除一个工作，或者重启等等</span><br></pre></td></tr></table></figure><p>#kill的使用格式如下<br>kill -signal %jobnumber</p><p>#signal从1-64个信号值可以选择，可以这样查看<br>kill －l</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|信号值|作用|</span><br><span class="line">|---|---|</span><br><span class="line">|-1| 	重新读取参数运行，类似于restart|</span><br><span class="line">|-2|如同 ctrl+c 的操作退出|</span><br><span class="line">|-9|强制终止该任务|</span><br><span class="line">|-15|正常的方式终止该任务|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 若是在使用`kill＋信号值然后直接加 pid`，你将会对 pid 对应的进程进行操作</span><br><span class="line">- 若是在使用`kill+信号值然后 ％jobnumber`，这时所操作的对象是 job，这个数字就是就当前 `bash` 中后台的运行的 job 的 ID</span><br><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">## 十七、进程管理</span><br><span class="line">- `top `工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:</span><br><span class="line"></span><br><span class="line">        $ top</span><br><span class="line">        </span><br><span class="line">    top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。</span><br><span class="line">    </span><br><span class="line">|内容|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|top| 	表示当前程序的名称|</span><br><span class="line">|11:05:18| 	表示当前的系统的时间|</span><br><span class="line">|up 8 days,17:12| 	表示该机器已经启动了多长时间|</span><br><span class="line">|1 user| 	表示当前系统中只有一个用户|</span><br><span class="line">|load average: 0.29,0.20,0.25|分别对应1、5、15分钟内cpu的平均负载|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 我们该如何看待这个load average 数据呢？</span><br></pre></td></tr></table></figure><p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。</p><pre><code>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 我们可以通过以下的命令来查看 CPU 的个数与核心数</span><br></pre></td></tr></table></figure><p>#查看物理CPU的个数</p><p>#cat /proc/cpuinfo |grep “physical id”|sort |uniq|wc -l</p><p>#每个cpu的核心数<br>cat /proc/cpuinfo |grep “physical id”|grep “0”|wc -l</p><p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p><pre><code>若是 load &lt; 0.7 并不会去关注他；
若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；
若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；
若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</span><br><span class="line">- 查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码</span><br></pre></td></tr></table></figure><p>#define FSHIFT 11 /* nr of bits of precision */</p><p>#define FIXED_1 (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point(定点) */</p><p>#define LOAD_FREQ (5<em>HZ) /</em> 5 sec intervals，每隔5秒计算一次平均负载值 */</p><p>#define CALC_LOAD(load, exp, n)<br>load <em>= exp;<br>load += n</em>(FIXED_1 - exp);<br>load &gt;&gt;= FSHIFT;</p><p>unsigned long avenrun[3];</p><p>EXPORT_SYMBOL(avenrun);</p><p>/*</p><ul><li>calc_load - given tick count, update the avenrun load estimates.</li><li>This is called while holding a write_lock on xtime_lock.</li><li>/<br>static inline void calc_load(unsigned long ticks)<br>{<pre><code>unsigned long active_tasks; /* fixed-point */
static int count = LOAD_FREQ;
count -= ticks;
if (count &lt; 0) {
        count += LOAD_FREQ;
        active_tasks = count_active_tasks();
        CALC_LOAD(avenrun[0], EXP_1, active_tasks);
        CALC_LOAD(avenrun[1], EXP_5, active_tasks);
        CALC_LOAD(avenrun[2], EXP_15, active_tasks);
}</code></pre>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **top 的第二行数据**</span><br><span class="line">|内容|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|Tasks: 26 total|进程总数 　|</span><br><span class="line">|1 running|1个正在运行的进程数|</span><br><span class="line">|25 sleeping|25个睡眠的进程数|</span><br><span class="line">|0 stopped|　没有停止的进程数|</span><br><span class="line">|0 zombie|没有僵尸进程数|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **top 的第三行数据**</span><br><span class="line"></span><br><span class="line">|内容|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|Cpu(s): 1.0%us| 	用户空间进程占用CPU百分比　|</span><br><span class="line">|1.0% sy|内核空间运行占用CPU百分比|</span><br><span class="line">|0.0%ni|用户进程空间内改变过优先级的进程占用CPU百分比|</span><br><span class="line">|97.9%id| 	空闲CPU百分比|</span><br><span class="line">|0.0%wa| 	等待输入输出的CPU时间百分比|</span><br><span class="line">|0.1%hi|硬中断(Hardware IRQ)占用CPU的百分比|</span><br><span class="line">|0.0%si|软中断(Software IRQ)占用CPU的百分比|</span><br><span class="line">|0.0%st| 	(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比|</span><br><span class="line"></span><br><span class="line">`CPU 利用率`是对一个时间段内 CPU 使用状况的统计，而`Load Average `是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的**进程数情况**统计信息，这两个指标并不一样。</span><br><span class="line"></span><br><span class="line">|内容|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|8176740 total| 	物理内存总量　|</span><br><span class="line">|8032104 used|使用的物理内存总量|</span><br><span class="line">|144636 free|空闲内存总量|</span><br><span class="line">|313088 buffers|　用作内核缓存的内存量|</span><br><span class="line"></span><br><span class="line">**系统中可用的物理内存最大值并不是 `free `这个单一的值，而是 `free + buffers + swap` 中的 cached 的和**</span><br><span class="line"></span><br><span class="line">- **top 的第五行数据**</span><br><span class="line">|内容|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|total| 交换区总量　|</span><br><span class="line">| used|使用的交换区总量|</span><br><span class="line">|free|空闲交换区总量|</span><br><span class="line">|cached|　缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **进程的情况**</span><br><span class="line">|列名|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|PID| 进程id　|</span><br><span class="line">|USER|该进程的所属用户|</span><br><span class="line">|PR|该进程执行的优先级 priority 值|</span><br><span class="line">|NI| 	该进程的 nice 值|</span><br><span class="line">|VIRT| 	该进程任务所使用的虚拟内存的总数|</span><br><span class="line">|RES|该进程所使用的物理内存数，也称之为驻留内存数|</span><br><span class="line">|SHR|该进程共享内存的大小|</span><br><span class="line">|S| 该进程进程的状态: S=sleep R=running Z=zombie|</span><br><span class="line">|%CPU|该进程CPU的利用率|</span><br><span class="line">|%MEM| 	该进程内存的利用率|</span><br><span class="line">|TIME+|该进程活跃的总时间|</span><br><span class="line">|COMMAND| 	该进程运行的名字|</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line">   ***注意</span><br><span class="line">    `NICE 值`叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</span><br><span class="line">    `PR` 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</span><br><span class="line">    其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</span><br><span class="line">    ** VIRT **任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数**</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">|常用交互命令|解释|</span><br><span class="line">|---|---|</span><br><span class="line">|q|退出程序|</span><br><span class="line">|I| 	切换显示平均负载和启动时间的信息|</span><br><span class="line">|P|根据CPU使用百分比大小进行排序|</span><br><span class="line">|M|根据驻留内存大小进行排序|</span><br><span class="line">|i|忽略闲置和僵死的进程，这是一个开关式命令|</span><br><span class="line">|k|终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **`ps` 工具的使用**</span><br><span class="line"></span><br><span class="line">        $ ps aux</span><br><span class="line">$ ps axjf</span><br><span class="line"></span><br><span class="line">![17](http://img1.ph.126.net/yH0Yk5wXQPfmXg9O46OY5A==/289637751135749590.png)</span><br><span class="line">![18](http://img1.ph.126.net/ioHXdRjG74pPGuDWJEvHxA==/5717526435133408738.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`TPGID`栏写着`-1`的都是没有控制终端的进程，也就是守护进程</span><br><span class="line">    `STAT`表示进程的状态，而进程的状态有很多，如下表所示</span><br><span class="line">![19](http://img0.ph.126.net/SFpmGa5_oRSc8xGlxOtOKw==/6632715933630913965.png)</span><br><span class="line"></span><br><span class="line">**其中的` D `是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 `signal`，所以无法使用 `kill` 命令杀掉处于D状态的进程，无论是 `kill`，`kill -9` 还是 `kill -15`，一般处于这种状态可能是进程 I/O 的时候出问题了。**</span><br><span class="line"></span><br><span class="line">- 使用` -l `参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来</span><br><span class="line"></span><br><span class="line">        $ ps -l</span><br><span class="line">- 罗列出所有的进程信息</span><br><span class="line"></span><br><span class="line">        $ ps aux</span><br><span class="line">- 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用</span><br><span class="line"></span><br><span class="line">        $ ps aux | grep zsh</span><br><span class="line">        </span><br><span class="line">- 此外我们还可以查看时，将连同部分的进程呈树状显示出来</span><br><span class="line"></span><br><span class="line">        $ ps axjf</span><br><span class="line">        </span><br><span class="line">- 当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示</span><br><span class="line"></span><br><span class="line">        $ ps -afxo user,ppid,pid,pgid,command</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">#### **pstree 工具的使用**</span><br><span class="line">- 通过`pstree `可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。</span><br><span class="line"></span><br><span class="line">        $ pstree</span><br></pre></td></tr></table></figure></li></ul><p>pstree -up</p><p>#参数选择：</p><p>#-A ：各程序树之间以 ASCII 字元來連接；</p><p>#-p ：同时列出每个 process 的 PID；</p><p>#-u ：同时列出每个 process 的所屬账户名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### **kill 命令的掌握**</span><br><span class="line">- 当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个` SIGHUP `信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 `kill` 来发送这个信号来操作进程的结束或者重启等等。</span><br><span class="line">- 用 kill 来操作下一些不属于 `job` 范畴的进程，直接对` pid` 下手</span><br></pre></td></tr></table></figure><p>#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到<br>ps aux</p><p>#使用9这个信号强制结束 gedit 进程<br>kill -9 1608</p><p>#我们再查找这个进程的时候就找不到了<br>ps aux | grep gedit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### **进程的执行顺序**</span><br><span class="line"></span><br><span class="line">- **当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 `PR `与 `nice `来控制与体现了</span><br><span class="line"></span><br><span class="line">- 而 `nice `的值我们是可以通过 `nice `命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 `root` 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制**</span><br></pre></td></tr></table></figure><p>#这个实验在环境中无法做，因为权限不够，可以自己在本地尝试</p><p>#打开一个程序放在后台，或者用图形界面打开<br>nice -n -5 vim &amp;</p><p>#用 ps 查看其优先级<br>ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 我们还可以用 `renice `来修改已经存在的进程的优先级</span><br><span class="line"></span><br><span class="line">        $ renice -5 pid</span><br><span class="line">  </span><br><span class="line">&amp;emsp;</span><br><span class="line">        </span><br><span class="line">## 十八、Ｌｉｎｕｘ日志</span><br><span class="line">- 常见的日志一般存放在 `/var/log` 中</span><br><span class="line"></span><br><span class="line">        $ ll /var/log</span><br><span class="line">- **系统日志**主要是存放系统内置程序或系统内核之类的日志信息如 `alternatives.log` 、`btmp` 等等，**应用日志**主要是我们装的第三方应用所产生的日志如 `tomcat7` 、`apache2 `等等。</span><br><span class="line">![20](http://img1.ph.126.net/ZUUdPJEfnjle0q9lvITvKg==/1867023520622245825.png)</span><br><span class="line">![21](http://img1.ph.126.net/NDkStFsCOjchiU7BgZYr5Q==/132574714131205387.png)</span><br><span class="line"></span><br><span class="line">- 我们用这样的命令来看看 `auth.log `中的信息</span><br><span class="line"></span><br><span class="line">        less auth.log</span><br><span class="line">- 在 `apt` 文件夹中的日志信息，其中有两个日志文件 `history.log` 与 `term.log`，两个日志文件的区别在于 `history.log` 主要记录了进行了哪个操作，相关的依赖有哪些，而` term.log` 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</span><br><span class="line"></span><br><span class="line">- 而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 `less`、`cat`、`more` 这样的工具来查看，这两个日志文件是 `wtmp`，`lastlog`</span><br><span class="line">- 我们查看的方法是使用 `last` 与 `lastlog` 工具来提取其中的信息</span><br><span class="line">![22](http://img0.ph.126.net/3i2OcafHap2sc5QFFCszNQ==/2111062325430211188.png)</span><br><span class="line"></span><br><span class="line">- `syslog `是一个系统日志记录程序，虽然时代的进步与发展，`syslog` 已经年老体衰跟不上时代的需求，所以他被 `rsyslog`所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</span><br><span class="line">- `rsyslog `可以提供超过每秒一百万条消息给目标文件。这样能实时收集日志信息的程序是有其守护进程的，如 `rsyslog `的守护进程便是 `rsyslogd`</span><br><span class="line">- 手动开启这项服务，然后来查看</span><br></pre></td></tr></table></figure><p>sudo apt-get update<br>sudo apt-get install -y rsyslog<br>sudo service rsyslog start<br>ps aux | grep syslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### **配置的日志**</span><br><span class="line">- rsyslog 的配置文件有两个:`/etc/rsyslog.conf`、`/etc/rsyslog.d/50-default.conf</span><br><span class="line">- 第一个主要是配置的环境，也就是` rsyslog` 加载什么模块，文件的所属者等；而第二个主要是配置的 `Filter Conditions`</span><br><span class="line"></span><br><span class="line">        vim /etc/rsyslog.conf </span><br><span class="line">        vim /etc/rsyslog.d/50-default.conf</span><br><span class="line">        </span><br><span class="line">- 看看 `rsyslog` 的结构框架</span><br><span class="line">![23](http://img0.ph.126.net/RuoOkHeNZ82i0hG6MoeykA==/6597321554821579281.png)</span><br><span class="line">- 首先通过 `Input module `来收集消息，然后将得到的消息传给 `Parser module`，通过分析模块的层层处理，将真正需要的消息传给 `Output module`，然后便输出至日志文件中。</span><br><span class="line">![24](http://img1.ph.126.net/0YmrK5kjqxT6X0QViOXROw==/1600185242700524827.png)</span><br><span class="line"></span><br><span class="line">- rsyslog 还有一个核心的功能模块便是 `Queue`，也正是因为它才能做到如此高的并发。</span><br><span class="line"></span><br><span class="line">- 第一个模块便是 `Input`，该模块的主要功能就是从各种各样的来源收集 `messages`，通过这些接口实现：</span><br><span class="line">![25](http://img2.ph.126.net/MzqAsvmPaioqyOgwSLBAig==/1286622118564788740.png)</span><br><span class="line"></span><br><span class="line">- 而 `Output `中也有许多可用的接口，可以通过` man `或者官方的文档查看</span><br><span class="line">而这些模块接口的使用需要通过 `$ModLoad` 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 `imklog`、`imuxsock` 这两个模块</span><br><span class="line"></span><br><span class="line">- 在配置中 rsyslog 支持三种配置语法格式：</span><br></pre></td></tr></table></figure><pre><code>sysklogd
legacy rsyslog
RainerScript</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `sysklogd `是老的简单格式，一些新的语法特性不支持。而 `legacy rsyslog` 是以 `dollar 符($)`开头的语法，在 `v6` 及以上的版本还在支持，就如上文所说的` $ModLoad` 还有一些插件和特性只在此语法下支持。而以` $` 开头的指令是全局指令，全局指令是` rsyslogd` 守护进程的配置指令，每行只能有一个指令。 `RainnerScript` 是最新的语法。在官网上 `rsyslog` 大多推荐这个语法格式来配置</span><br><span class="line"></span><br><span class="line">- 老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</span><br><span class="line"></span><br><span class="line">- 注释有两种语法:</span><br><span class="line"></span><br><span class="line">        井号 #</span><br><span class="line">        C-style /* .. */</span><br><span class="line">- 执行顺序: 指令在 `rsyslog.conf` 文件中是从上到下的顺序执行的。</span><br><span class="line"></span><br><span class="line">- 模板是 `rsyslog` 一个重要的属性，它可以控制日志的格式，支持类似 `template() `语句的基于` string` 或 `plugin` 的模板，通过它我们可以自定义日志格式。</span><br><span class="line"></span><br><span class="line">- `**legacy` 格式使用 `$template` 的语法，不过这个在以后要移除，所以最好使用新格式 `template():`，以免未来突然不工作了也不知道为什么**</span><br><span class="line"></span><br><span class="line">- 模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 `string `的形式，复杂的格式，建议使用 `list` 的形式，使用` list` 的形式，可以使用一些额外的属性字段（property statement）</span><br><span class="line"></span><br><span class="line">- 如果不指定输出模板，rsyslog 会默认使用 `RSYSLOG_DEFAULT`。若想更深入的学习可以查看官方文档</span><br><span class="line"></span><br><span class="line">- 了解了 rsyslog 环境的配置文件之后，我们看向 `/etc/rsyslog.d/50-default.conf` 这个配置文件，这个文件中主要是配置的 `Filter Conditions`，也就是我们在流程图中所看见的 `Parser &amp; Filter Engine`,它的名字叫 `Selectors` 是过滤 syslog 的传统方法，他主要由两部分组成，`facility `与 `priority`，其配置格式如下</span><br><span class="line"></span><br><span class="line">        facility.priority　　　　　log_location</span><br><span class="line">        </span><br><span class="line">- 其中一个 `priority `可以指定多个 `facility`，多个 facility 之间使用逗号` , `分割开</span><br><span class="line"></span><br><span class="line">- rsyslog 通过 `Facility` 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</span><br><span class="line">![26](http://img2.ph.126.net/uGbgeVMh8Fg4thmKvJ_jaw==/874261277763834635.png)</span><br><span class="line"></span><br><span class="line">- 而另外一部分 `priority` 也称之为` serverity level`，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有一下几种：</span><br><span class="line">![27](http://img2.ph.126.net/JgcYNCjWDJ9yl7Y7lR1ArQ==/1241023172417744477.png)</span><br><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### **看系统中的配置**</span><br><span class="line"></span><br><span class="line">        auth,authpriv.*       /var/log/auth.log</span><br><span class="line">这里的意思是 `auth `与 `authpriv` 的所有优先级的信息全都输出于 `/var/log/auth.log `日志中</span><br><span class="line"></span><br><span class="line">- 而其中有类似于这样的配置信息意思有细微的差别</span><br><span class="line"></span><br><span class="line">        kern.*      -/var/log/kern.log</span><br></pre></td></tr></table></figure><ul><li>代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</li></ul><p>到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看官网的文档,需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 与日志相关的还有一个还有常用的命令` logger`,`logger` 是一个 `shell` 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</span><br></pre></td></tr></table></figure><p>#首先将syslog启动起来<br>sudo service rsyslog start</p><p>#向 syslog 写入数据<br>ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</p><p>#查看是否有数据写入<br>sudo tail -f /var/log/syslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|参数|内容|</span><br><span class="line">|---|---|</span><br><span class="line">|-i|在每行都记录进程 ID|</span><br><span class="line">|-t|添加 tag 标签|</span><br><span class="line">|-p|设置日志的 facility 与 priority|</span><br><span class="line"></span><br><span class="line">&amp;emsp;</span><br><span class="line"></span><br><span class="line">### **日志转储**</span><br><span class="line">- `logrotate `程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</span><br><span class="line"></span><br><span class="line">- 大多数 Linux 发行版使用` logrotate` 或 `newsyslog` 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</span><br><span class="line"></span><br><span class="line">- 显而易见，logrotate 是基于` CRON` 来运行的，其脚本是 `/etc/cron.daily/logrotate`；同时我们可以在 `/etc/logrotate` 中找到其配置文件</span><br><span class="line"></span><br><span class="line">        cat /etc/logrotate.conf</span><br></pre></td></tr></table></figure><h1 id="see-“man-logrotate”-for-details-可以查看帮助文档"><a href="#see-“man-logrotate”-for-details-可以查看帮助文档" class="headerlink" title="see “man logrotate” for details  //可以查看帮助文档"></a>see “man logrotate” for details //可以查看帮助文档</h1><h1 id="rotate-log-files-weekly"><a href="#rotate-log-files-weekly" class="headerlink" title="rotate log files weekly"></a>rotate log files weekly</h1><p>weekly //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )</p><h1 id="keep-4-weeks-worth-of-backlogs"><a href="#keep-4-weeks-worth-of-backlogs" class="headerlink" title="keep 4 weeks worth of backlogs"></a>keep 4 weeks worth of backlogs</h1><p>rotate 4 //最多转储4次</p><h1 id="create-new-empty-log-files-after-rotating-old-ones"><a href="#create-new-empty-log-files-after-rotating-old-ones" class="headerlink" title="create new (empty) log files after rotating old ones"></a>create new (empty) log files after rotating old ones</h1><p>create //当转储后文件不存在时创建它</p><h1 id="uncomment-this-if-you-want-your-log-files-compressed"><a href="#uncomment-this-if-you-want-your-log-files-compressed" class="headerlink" title="uncomment this if you want your log files compressed"></a>uncomment this if you want your log files compressed</h1><p>compress //通过gzip压缩方式转储（nocompress可以不压缩）</p><h1 id="RPM-packages-drop-log-rotation-information-into-this-directory"><a href="#RPM-packages-drop-log-rotation-information-into-this-directory" class="headerlink" title="RPM packages drop log rotation information into this directory"></a>RPM packages drop log rotation information into this directory</h1><p>include /etc/logrotate.d //其他日志文件的转储方式配置文件，包含在该目录下</p><h1 id="no-packages-own-wtmp-–-we’ll-rotate-them-here"><a href="#no-packages-own-wtmp-–-we’ll-rotate-them-here" class="headerlink" title="no packages own wtmp – we’ll rotate them here"></a>no packages own wtmp – we’ll rotate them here</h1><p>/var/log/wtmp { //设置/var/log/wtmp日志文件的转储参数<br>monthly //每月转储<br>create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664<br>rotate 1 //最多转储一次<br>}</p><pre><code>
</code></pre><div class="post-announce">感谢您的阅读，本文由 <a href="https://github.com/BUGIsOne">Rakel's bolg</a> 版权所有。如若转载，请注明出处：Rakel's bolg（<a href="https://github.com/BUGIsOne/2019/09/17/Linux基本命令手册/">https://github.com/BUGIsOne/2019/09/17/Linux基本命令手册/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2019/09/17/c++基础语法学习/" title="c++基础语法学习"><i class="iconfont icon-prev"></i>c++基础语法学习</a></div><div class="post__prev post__prev--right"><a href="/2019/09/17/hello-world/" title="hello, world">hello, world<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/os/">os</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/html/">html</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/c/">c++</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/algorithm/">algorithm</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/09/17/hello-world/" title="hello, world"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="hello, world"></div><div class="item__info"><h3 class="item__title">hello, world</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/Linux基本命令手册/" title="linux基本命令手册"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="linux基本命令手册"></div><div class="item__info"><h3 class="item__title">linux基本命令手册</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/c++基础语法学习/" title="c++基础语法学习"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="c++基础语法学习"></div><div class="item__info"><h3 class="item__title">c++基础语法学习</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/blog搭建笔记/" title="skapp 主题博客搭建笔记"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="skapp 主题博客搭建笔记"></div><div class="item__info"><h3 class="item__title">skapp 主题博客搭建笔记</h3><span class="item__text">2019-09-17</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/blog/">blog</a></li><li class="tag-item"><a class="tag-link" href="/tags/kmp/">kmp</a></li><li class="tag-item"><a class="tag-link" href="/tags/linux/">linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/语法/">语法</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Chengdu, Sichuan Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>937459807@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="../images/IMG_20190917_184101.png" alt="logo" title="Rakel's bolg"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/BUGIsOne" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:937459807@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>