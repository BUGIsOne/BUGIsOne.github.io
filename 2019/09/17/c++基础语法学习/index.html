<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>c++基础语法学习 | Outing myself</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="null"><meta name="description" content="日常学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://github.com/BUGIsOne/2019/09/17/c++基础语法学习/index.html"><link rel="icon" type="image/png" href="../images/164009528604.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Rakel's bolg"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://blog.static.minfive.com/other/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Rakel's bolg" alt="Rakel's bolg"><img src="../images/164009528604.jpg" alt="Rakel's bolg"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="c++基础语法学习"></div><header class="post__info"><h1 class="post__title">c++基础语法学习</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/BUGIsOne">Rakel</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-09-17</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/语法/">语法</a></li></ul></div></div></header><div class="post__content"><h2 id="在线地址-https-www-zybuluo-com-re-start-note-1239968"><a href="#在线地址-https-www-zybuluo-com-re-start-note-1239968" class="headerlink" title="在线地址:https://www.zybuluo.com/re-start/note/1239968"></a>在线地址:<a href="https://www.zybuluo.com/re-start/note/1239968" target="_blank" rel="noopener">https://www.zybuluo.com/re-start/note/1239968</a></h2><h3 id="C-STL"><a href="#C-STL" class="headerlink" title="C++STL"></a>C++STL</h3><h4 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h4><ul><li><p>在STL中<code>unique</code>函数是一个去重函数， unique的功能是去除相邻的重复元素(只保留一个),其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中，然后 返回去重后最后一个元素的地址，因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p></li><li><p>unique <strong>返回的迭代器</strong> 指向超出无重复的元素范围末端的下一个位置。</p></li><li><p><strong>注意</strong>：算法不直接修改容器的大小。如果需要添加或删除元素，则必须使用容器操作。<br>去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(), vec.end());</span><br><span class="line">auto end_unique = unique(vec.begin(), vec.end());//得到不重复区域的后一位</span><br><span class="line">vec.erase(end_unique, vec.end());</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream&gt;</span><br><span class="line"> 2 #include &lt;cassert&gt;</span><br><span class="line"> 3 #include &lt;algorithm&gt;   //unique</span><br><span class="line"> 4 #include &lt;vector&gt;</span><br><span class="line"> 5 #include &lt;string&gt;</span><br><span class="line"> 6 #include &lt;iterator&gt;</span><br><span class="line"> 7 using namespace std;</span><br><span class="line"> 8 </span><br><span class="line"> 9 int main()</span><br><span class="line">10 &#123;</span><br><span class="line">11     //cout&lt;&lt;&quot;Illustrating the generic unique algorithm.&quot;&lt;&lt;endl;</span><br><span class="line">12     const int N=11;</span><br><span class="line">13     int array1[N]=&#123;1,2,0,3,3,0,7,7,7,0,8&#125;;</span><br><span class="line">14     vector&lt;int&gt; vector1;</span><br><span class="line">15     for (int i=0;i&lt;N;++i)</span><br><span class="line">16         vector1.push_back(array1[i]);</span><br><span class="line">17 </span><br><span class="line">18     vector&lt;int&gt;::iterator new_end;</span><br><span class="line">19     new_end=unique(vector1.begin(),vector1.end()); //&quot;删除&quot;相邻的重复元素</span><br><span class="line">20 &#125;</span><br></pre></td></tr></table></figure><ul><li><p>unique_copy函数<br>接受第三个迭代器实参，用于指定复制不重复元素的目标序列。</p></li><li><p>将一个list对象中不重复的元素赋值到一个空的vector对象中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 3 #include&lt;iostream&gt;</span><br><span class="line"> 4 #include&lt;list&gt;</span><br><span class="line"> 5 #include&lt;vector&gt;</span><br><span class="line"> 6 #include&lt;algorithm&gt;</span><br><span class="line"> 7 using namespace std;</span><br><span class="line"> 8 </span><br><span class="line"> 9 int main()</span><br><span class="line">10 &#123;</span><br><span class="line">11     int ia[7] = &#123;5 , 2 , 2 , 2 , 100 , 5 , 2&#125;;</span><br><span class="line">12     list&lt;int&gt; ilst(ia , ia + 7);</span><br><span class="line">13     vector&lt;int&gt; ivec;</span><br><span class="line">14 </span><br><span class="line">15     //将list对象ilst中不重复的元素复制到空的vector对象ivec中</span><br><span class="line">16     //sort(ilst.begin() , ilst.end());  //不能用此种排序，会报错</span><br><span class="line">17     ilst.sort();  //在进行复制之前要先排序，切记</span><br><span class="line">18     unique_copy(ilst.begin() , ilst.end() , back_inserter(ivec));</span><br><span class="line">19     //list内本身没有去重</span><br><span class="line"></span><br><span class="line">20     //输出vector容器</span><br><span class="line">21     cout&lt;&lt;&quot;vector: &quot;&lt;&lt;endl;</span><br><span class="line">22     for(vector&lt;int&gt;::iterator iter = ivec.begin() ; iter != ivec.end() ; ++iter)</span><br><span class="line">23         cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;</span><br><span class="line">24     cout&lt;&lt;endl;</span><br><span class="line">25 </span><br><span class="line">26     return 0;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输入<br><code>getline(is, str)</code>读取一行的内容,包括换行符，str不存而已</p><h4 id="初始化vector的方法"><a href="#初始化vector的方法" class="headerlink" title="初始化vector的方法:"></a>初始化vector的方法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1</span><br><span class="line">vector&lt;T&gt; v2(v1)</span><br><span class="line">vector&lt;T&gt; v2 = v2</span><br><span class="line">vector&lt;T&gt; v3(n, val)</span><br><span class="line">vector&lt;T&gt; v4(n)//v4包含了n个重复执行初始化的对象</span><br><span class="line">vector&lt;T&gt; v5&#123;a,b,c..&#125;</span><br><span class="line">vector&lt;T&gt; v6 = &#123;a,b,c..&#125;</span><br></pre></td></tr></table></figure><p>若是返回vector&lt;&gt;的函数，可以return多个其中的元素。<br>c11规定函数可以返回 <strong>花括号</strong> 的值列表，相当于初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; case()</span><br><span class="line">&#123;</span><br><span class="line">	if(//)</span><br><span class="line">		return &#123;&#125;;</span><br><span class="line">	if()</span><br><span class="line">		return &#123;&quot;hi&quot;, &quot;world&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec), 10, 0)//错误,vec元素为空</span><br><span class="line">fill_n(back_inserter(vec), 10, 0);//插入迭代器，相当于每次赋值都会调用push_back()</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(vec.begin(), vec.end(), 0, 42)//将是0的替换为42</span><br><span class="line">replace_copy(vec.begin(), vec.end(), back_inserter(ivec), 0, 42)//不改变原来的vec，将结果保留在ivec</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><blockquote><p>find(v.begin(), v.end(), ‘ ‘);//找到返回第三个参数的位置，否则返回第二个参数位置的拷贝</p></blockquote><h4 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h4><blockquote><p>auto it = eaual_range(v.begin(), v.end(), value, compare);//第四个参数可选，默认升序排序，返回一个迭代器</p></blockquote><p>未找到等于value的，两个迭代器相等，否则it.begin()为找到的第一个，it.second()为最后一个的尾后</p><h4 id="lambda：用作函数参数；一元谓词时，即只接受单一参数"><a href="#lambda：用作函数参数；一元谓词时，即只接受单一参数" class="headerlink" title="lambda：用作函数参数；一元谓词时，即只接受单一参数"></a>lambda：用作函数参数；一元谓词时，即只接受单一参数</h4><pre><code>要求:[capture list](parameter list) -&gt; return type {function body}
捕获列表是lambda所在函数的局部变量列表（通常为空），捕获了才能用。必须使用尾置类型表示返回值。
可以省略参数列表和返回类型。lambda不能使用默认参数，所以形参数目与实参数目永远相等。</code></pre><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto wc = find_if(words.begin(), words.end(), </span><br><span class="line">	[sz] (const string &amp;s)</span><br><span class="line">		 &#123;return s.size() &gt;= sz;&#125; );</span><br></pre></td></tr></table></figure><pre><code>find_if()第三个参数bool型, wc返回第一个使第三个参数不为0的位置，否则返回words.end()的拷贝.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), </span><br><span class="line">	[] (const string &amp;s) </span><br><span class="line">	   &#123;cout&lt;&lt; s &lt;&lt; endl;&#125; );</span><br></pre></td></tr></table></figure><p>for_each,对区域内每个元素调用第三个参数</p><p><strong>特性</strong>：<br>lambda被捕获变量的值在lambda创建时拷贝，不是调用时。即调用时不会改变变量的值<br>流对象不能被拷贝，所以只能捕获其引用<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	size_t v1 = 42;</span><br><span class="line">	auto f = [v1] &#123; return v1; &#125;;//v1的引用就不一样</span><br><span class="line">	v1 = 0;</span><br><span class="line">	auto j = f();//j为42</span><br><span class="line">```	</span><br><span class="line">	</span><br><span class="line">隐式捕获：编译器根据lambda中的代码推断我们要使用的变量</span><br><span class="line">	[=] 值捕获，[&amp;] 捕获引用</span><br><span class="line">	混用：[&amp;, ans..],[=, &amp;ans..&amp;..],隐式打头，后面显示就要指明是什么引用</span><br><span class="line">可变lambda：可以省略参数列表，在其后加上mutable</span><br><span class="line">特性：</span><br><span class="line">如果未使用尾置返回类型，lambda函数体内又不止return语句，则返回void</span><br></pre></td></tr></table></figure><p>transform(v.begin(), v.end(), v.begin(),<br>[] (int i) { return i&lt;0:-i?i; } );<br>第三个参数指目的位置，第四个参数对每个元素的调用</p><p>remove_if(v.begin(), v.end(),<br>[] (int i) { return i % 2; } );//删除奇数<br>remove_copy_if(v.begin(), v.end(), back_inserter(v2),<br>[] (int i) { return i % 2; } );//v不变，将使谓词为0的拷贝到v2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**特性**：</span><br><span class="line">	_copy版本, _if版本接受一个目的位置和一个谓词</span><br><span class="line"></span><br><span class="line">&gt;reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;functional&gt;</span><br><span class="line">#### bind绑定:</span><br><span class="line">	auto newCallable = bind(callable, arg_list);</span><br><span class="line">例子:</span><br></pre></td></tr></table></figure><pre><code>auto check6 = bind(check_size, _1, 6);//_1占位符表示第一个参数，_2,_3..
string s = &quot;hello&quot;;
check6(s);//会调用check_size(s, 6);
除了写using ..std, 还要写using std::placeholders::_1;
另外一种: using namespace std::placeholders;

auto g = bind(f, a, b, _2, c，_1);
g(x, y);//即f(a, b, y, c ,x)拷贝给的参数;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure><pre><code>ostream &amp;print(ostream &amp;os, const string &amp;s, char c) {}
//for_each(words.begin(), words.end(), bind(print, os, _1, &apos; &apos;) );
不能拷贝一个ostream
for_each(words.begin(), words.end(), bind(print, ref(os), _1, &apos; &apos;) );//red返回一个对象，包含给定的引用，此返回对象可拷贝；还有一个cref      </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 反向迭代器</span><br><span class="line"></span><br><span class="line">    rbegin(),rend():</span><br><span class="line">    </span><br><span class="line">	   空      0      1      2        3             4     </span><br><span class="line">	rend()					      rbegin()++     rbegin()</span><br><span class="line"></span><br><span class="line">&gt;将反向迭代器变为普通迭代器，以免它在字符串中反向移动,使用reverse_iterator的base</span><br><span class="line">	</span><br><span class="line">```	</span><br><span class="line">	auto rcomma = find(str.rbegin(), str.rend(), &apos; &apos;); </span><br><span class="line">	cout&lt;&lt;string(rcomma.base, str.end() );//指向的是rcomma后一位</span><br></pre></td></tr></table></figure><p>插入迭代器</p><blockquote><p>back_inserter//只有容器支持push_back才能使用<br>front_inserter//只有容器支持push_front才能使用<br>inserter</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; lst = &#123;1 , 2 , 3 , 4&#125;;</span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(lst2) );</span><br><span class="line">//lst2 = &#123;4 , 3 , 2 , 1&#125;;每个插入元素变为新的头元素</span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3) );</span><br><span class="line">//lst3 = &#123;1 , 2 , 3 , 4&#125;;</span><br></pre></td></tr></table></figure><p>sort要求能随机访问的迭代器，所以链表类型没有sort</p><h4 id="链表容器"><a href="#链表容器" class="headerlink" title="链表容器"></a>链表容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst1.merge(lst2);</span><br><span class="line">lst1.merge(lst2, cmp);//lst1，lst2都必须是有序的，合并后lst2为空，第二个参数可选，默认从小到大</span><br><span class="line"></span><br><span class="line">lst1.remove(val);</span><br><span class="line">lst1.remove_if(pred);//删除给定值，或令一元谓词为真的每个值</span><br><span class="line"></span><br><span class="line">lst.reverse();</span><br><span class="line">lst.sort(cmp);//参数可选</span><br><span class="line">lst.unique(pred);//参数可选，二元谓词</span><br></pre></td></tr></table></figure><p>关联容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::类型名</span><br><span class="line">key_type</span><br><span class="line">mapped_type</span><br><span class="line">value_type 	对于map，为pair&lt;const key_type, mapped_type&gt;</span><br><span class="line">			对于set, 与key_type相同</span><br><span class="line">也有iterator,-&gt;first是const</span><br></pre></td></tr></table></figure><p>操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.insert(val);</span><br><span class="line">c.insert(p, v);</span><br><span class="line">c.emplace(args);</span><br><span class="line">c.insert(b, e);</span><br><span class="line">c.insert(inl);//花括号的对象</span><br><span class="line">c.emplace(p, args);//返回pair，first是指出元素的迭代器，second是bool，是否插入成功</span><br></pre></td></tr></table></figure><p>map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c[k]//返回关键值为k的元素，不在则初始化</span><br><span class="line">c.at(k)//访问，若不在则报错</span><br><span class="line">非const的map和无序map</span><br><span class="line"></span><br><span class="line">c.find(key)//不在返回尾后迭代器</span><br><span class="line">c.count(key)//还会计数的，对于不允许重复的只有0和1</span><br><span class="line">c.lower_bound(k)//返回第一个小于k关键值的迭代器</span><br><span class="line">c.upper_bound(k)//返回第一个大于k关键值的迭代器</span><br><span class="line">c.equal_range(k)//返回迭代器pair，表示等于k关键值的范围，若没有，则first和second都是end()</span><br></pre></td></tr></table></figure><p>对于multimap，若关键字在容器中，lower返回第一个，upper返回最后一个匹配的元素之后的位置。不存在，则它们返回一个不影响排序的同一迭代器</p><p>multiset&lt;关键字类型，比较类型(通常是函数指针)&gt; name(比较函数name)<br>例子</p><blockquote><p>multiset&lt;shared_ptr<q>, decltype(compare)*&gt; items(compare);<br>items.count(k);//返回该关键字的个数</q></p></blockquote><h4 id="智能指针share-ptr"><a href="#智能指针share-ptr" class="headerlink" title="智能指针share_ptr"></a>智能指针share_ptr</h4><p>特性：<br>当ptr被销毁时，它所指的对象还有其他使用者，该内存就不会释放<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg)</span><br><span class="line">&#123;</span><br><span class="line">	shared_ptr&lt;Foo&gt; p = factory(arg);</span><br><span class="line">&#125;//p离开了作用域，它指向的内存会自动释放</span><br><span class="line">void use_factory(T arg)</span><br><span class="line">&#123;</span><br><span class="line">	shared_ptr&lt;Foo&gt; p = factory(arg);</span><br><span class="line">	return 	p;</span><br><span class="line">&#125;//return语句向此函数的调用者返回一个p的拷贝，会增加shared_ptr管理对象的引用计数次数</span><br></pre></td></tr></table></figure><p>注意：<br>由内置指针，而不是智能指针管理的动态内存，不显式释放前会一直存在</p><p>特性：<br>内置指针不能隐式转换为智能指针，因为智能指针的构造函数是explicit的<br>而且一个用来初始化智能指针的普通指针必须先指向动态内存，没有对象，智能指针的特性就是自动销毁哒<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	shared_ptr&lt;int&gt; p1 = new int (1042);//错误</span><br><span class="line">	shared_ptr&lt;int&gt; p2(new int (1042) );//正确，使用了直接初始化</span><br><span class="line">函数：</span><br><span class="line">	q.reset();//若q是唯一指向该内存的，则会释放此内存，q置为空</span><br><span class="line">	q.reset(p);//将q指向p</span><br><span class="line">	q.reset(p, d);//对不是new初始化的类型调用d（可调用对象），而不是用delete释放内存</span><br><span class="line"></span><br><span class="line">	q.get()//返回一个内置指针，该内置指针的代码不要delete此指针。但它可以拷贝给另一个智能指针，</span><br><span class="line">	尬尴的情况，大家的计数各都是1，谁为0都会释放内存，让别人悬空。用时想仔细了！</span><br><span class="line">	q,unique()//bool查自己是不是唯一</span><br></pre></td></tr></table></figure><p>引用计数<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void process(shared_ptr&lt;int&gt; ptr)&#123;&#125;//ptr离开作用域，被销毁</span><br><span class="line">..</span><br><span class="line">shared_ptr&lt;int&gt; p(new int(42));  	创建，计数为1</span><br><span class="line">process(p);		函数形参是传值，会拷贝一波，计数为2。函数结束变为1</span><br><span class="line">int i = *p;		正确，计数为1，可以拿来用</span><br><span class="line"></span><br><span class="line">////////////////////</span><br><span class="line">int *x = new int(1022);			</span><br><span class="line">process(x);			错误，不会隐式转换为智能指针</span><br><span class="line">process(shared_ptr&lt;int&gt; (x) );	形式正确，计数只针对智能指针，创建时为1，结束为0，顺带把所指内存释放</span><br><span class="line">int j = *x;		x现在悬空，指向无效的内存</span><br></pre></td></tr></table></figure><p>指向数组:<br>必须提供自己的删除器</p><blockquote><p>shared_ptr<int>pr(new int [10], [] (int *p) {delete [] p;} );<br>sp.reset(); 使用提供的lambda</int></p></blockquote><p><strong>特性</strong>：不支持下标运算，智能通过get()来访问以及递增</p><p>unique_ptr<br>不能拷贝或赋值给别个<br>函数：</p><blockquote><p>u.release(); u放弃对内存的控制权，返回指针，u被置为空<br>unique_ptr<string>p2(p1.release() );</string></p></blockquote><p><strong>注意</strong>：只写u.release();u与原来内存断了联系，又没另外一个来接管，就不会释放内存</p><blockquote><p>特殊： unique_ptr&lt;int []&gt; u (new int [42]);<br>u.release();会自动调用delete [];<br>unique_ptr&lt;T, D&gt; u2(d); d可选参数，以类型为D的对象d代替delete</p></blockquote><h4 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h4><p>使用以下函数前，先分配内存</p><blockquote><p>allocateor<t>alloc;<br>auto q = alloc.allocate(vi.size() * 2); //返回该内存的地址（迭代器）</t></p></blockquote><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; il;结合alloc_n_copy(il.begin(), end());可以重载集合赋值的方式</span><br><span class="line"></span><br><span class="line">uninitialized_copy(b, e, b2);</span><br><span class="line">uninitialized_copy_n(b, n, b2);		返回构造最后一个元素的后一个位置</span><br><span class="line">uninitialized_fill(b, e, b2);</span><br><span class="line">uninitialized_fill_n(b, n, b2);</span><br><span class="line"></span><br><span class="line">alloc.construct(pos, val);	在pos出构造val的副本，</span><br><span class="line">alloc.destroy(pos);</span><br><span class="line">alloc.deallocate(b, n);		两个函数配套使用，destroy销毁元素，deallocate收回内存</span><br></pre></td></tr></table></figure><p>一个对象内有指针的声明，声明没有初始化，创建时指针为空，要分配内存<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   map&lt;string, shared_ptr&lt;set&lt;line_no&gt;   &gt;    &gt;  wm;</span><br><span class="line">..</span><br><span class="line">while(line &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">	auto &amp;kk = wm[word];	kk时shared_ptr的引用</span><br><span class="line">	if(!kk)				kk为空指针</span><br><span class="line">		kk.reset( new set&lt;line_no&gt; );	分配一个新的set</span><br><span class="line">	kk-&gt;insert(..);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右值引用绑右值，绑了以后变左值。左值引用绑左值</p><h4 id="移动构造函数std-move"><a href="#移动构造函数std-move" class="headerlink" title="移动构造函数std::move"></a>移动构造函数std::move</h4><utility>特性 想象每个string都有一个指向char数组的指针，可以假定string的移动构造函数进行了对指针的拷贝， 而不是为字符分配内存空间，然后拷贝(具体标准库string的移动构造函数尚未公开) IO类和unique_ptr不可拷贝但能移动 例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	void Str::reallocate()</span><br><span class="line">	&#123;</span><br><span class="line">		auto newcapacity = size()? size() * 2 : 1;</span><br><span class="line">		auto newdata = alloc.allocate(newcapacity);</span><br><span class="line">		auto dest = newdata;</span><br><span class="line">		auto elem = elements;//旧地址头</span><br><span class="line">		for(size_t i = 0; i != size(); i++)</span><br><span class="line">			alloc.construct(dest++, move(*elem++) ); </span><br><span class="line">		free();//消除旧地址内存</span><br><span class="line">		elements = newdata;</span><br><span class="line">		..</span><br><span class="line">	&#125;</span><br><span class="line">```	</span><br><span class="line">	</span><br><span class="line">**特性**</span><br><span class="line">	转化左值返回右值。移动函数参数用右值2，拷贝函数左右都行，当它们争时，具体看谁能精确匹配</span><br><span class="line">例子</span><br></pre></td></tr></table></figure><pre><code>int ee1 = 42; 
int &amp;&amp;ee2 = std::move(ee1);//使用std避免潜在的名称冲突

一般为了区分
void push_back(const T&amp;);
void push_back(T&amp;&amp;);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**特性**</span><br><span class="line">	只有一个类没有定义拷贝控制成员，并且每个非static数据成员都是可移动的，编译器才会为它合成移动构造函数或是移动拷贝函数；</span><br><span class="line">	如果定义了移动函数，则编译器合成的拷贝构造和拷贝赋值被定义为删除的(只要出现，就算定义成delete也是算定义了)</span><br><span class="line">注意：移后“源”要置为有效可析构的，当调用move后要确认移后“源对象”没有其他用户</span><br><span class="line">算法使用移动迭代器</span><br><span class="line">	使用make_move_iterator(iter);转化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 面向对象程序设计</span><br><span class="line">不想被继承：在类名后面加上final</span><br><span class="line">纯虚函数(= 0)：一般用于抽象基类，定义一个在基类没定义的函数，但之后在各继承类中有不同作用，抽象基类不能创建对象；</span><br><span class="line">		也可以在基类对纯虚函数定义，但必须在类外；派生类必须定义自己的从抽象基类来的纯虚函数，不然还是纯虚函数</span><br><span class="line"></span><br><span class="line">派生类只初始化直接基类；派生类的成员和友元函数，只能通过派生类对象来访问基类的protected，比如形参是派生类对象</span><br><span class="line"></span><br><span class="line">在类中合适的位置使用using：可以把成员分为派生类可用的和友元即该类成员可用的</span><br><span class="line"></span><br><span class="line">定义派生类的拷贝和移动构造函数：(初始化列表)</span><br><span class="line">	默认，基类默认构造函数初始化派生类对象的基类部分，但定义派生类的拷贝和移动时，必须显式地使用基类地拷贝和移动函数</span><br><span class="line">派生类赋值函数：(类内)</span><br></pre></td></tr></table></figure><pre><code>D &amp;D::operator = (const D &amp;rhs)
{
    base::operator = (rhs);//为基类部分赋值
    return *this;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">继承地构造函数</span><br><span class="line">**特性**：</span><br><span class="line">	不会改变访问级别；不能指定explcit和constexpr；默认实参不会被继承</span><br></pre></td></tr></table></figure><pre><code>class D : public base
{
    public:
        using base::base;//继承基类每个构造函数
    //相当于    D(arg) :
                base(arg) {}
    如果参数里含有派生类自己的成员，那么默认初始化
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">容器</span><br><span class="line">一般存放基类的智能指针而不是对象</span><br><span class="line"></span><br><span class="line">模拟虚拷贝</span><br></pre></td></tr></table></figure><pre><code>//D，A是一个类
D bsk;
bsk.add(make_shared&lt;A&gt; (&quot;123&quot;, 45));
为了接受一个A对象，而不是shared_ptr;改造add
void add(const A &amp;sale);    //拷贝
void add(A &amp;&amp;sale);            //移动

new A(sale);        //然而当实际指向的是A的派生类B，可能只会拷贝sale的A部分
//所以
class A
{
    public:
        virtual A* clone() const &amp; { return new A (*this); }//当前对象的动态分配的拷贝
        virtual A* clone() &amp;&amp; { return new A (std::move(*this)); }
};
class B : public A
{
    B* clone() const &amp; {return new B(*this);}
    B* clone() &amp;&amp; {return new B(std::move(*this)); }
};
class D
{
    public:
        void add(const A &amp;sale) {item.insert(shared_ptr&lt;A&gt; (sale.clone)); }//拷贝
        void add(A &amp;&amp;sale) {item.insert(shared_ptr&lt;A&gt; (std::move(sale.clone))); }//移动
};</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 成员指针</span><br></pre></td></tr></table></figure><pre><code>class Screen
{
    public:
        Screen&amp; home();
        Screen&amp;    forward();
        Screen&amp;    back();
        Screen&amp; up();
        Screen&amp;    down();

        using Action = Screen&amp; (Screen::*) ();//相当于typedef函数指针，返回一个Screen引用
        enum Directions {HOME, FORWARD, BACK, UP, DOWN};
        Screen&amp; move(Direction);
    private:
        static Action Menu[];//函数指针表
};

Screen&amp; Screen::move(Directions cm)
{
    return (this-&gt;*Menu[cm]) ();//-&gt;*或.*是对成员指针的解引用，使用者是该类对象的指针或者一个对象
}

Screen::Action Screen::Menu[] = {&amp;Screen::home, &amp;Screen::forward, &amp;Screen::back, &amp;Screen::up, &amp;Screen::down,};
//调用
Screen obj;
obj.move(Screen::HOME);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将成员函数生成可调用对象</span><br><span class="line">使用function</span><br><span class="line">&gt;	function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;//fcn是string的empty函数</span><br><span class="line">	find_if(str.begin(), str.end(), fcn);</span><br><span class="line"></span><br><span class="line">当定义一个function，必须指定类型，如果是成员函数，第一个形参必须表示该成员是在哪个对象(一般是隐式this)上执行的；</span><br><span class="line">还必须指明是以指针形式还是引用形式；</span><br><span class="line"></span><br><span class="line">使用mem_fn</span><br><span class="line">&gt;	find_if(str.begin(), str.end(), mem_fn(&amp;string::empty));</span><br><span class="line">mem_fn根据成员指针类型推断可调用对象的类型，返回一个bool</span><br><span class="line"></span><br><span class="line">使用bind</span><br><span class="line">&gt;	find_if(str.begin(), str.end(), bind(&amp;string::empty, _1));</span><br><span class="line">第一个实参可以是指针也可以是引用</span><br><span class="line"></span><br><span class="line">调用</span><br></pre></td></tr></table></figure><pre><code>auto f = mem_fn(&amp;string::empty);    
//auto f = bind(&amp;string::empty, _1);    

f(*str.begin());//引用
f(&amp;str[0]);//指针</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 多重继承</span><br><span class="line">如果多个基类有完全相同的构造函数(形参列表完全相同)，则派生类必须自定义出自己版本</span><br><span class="line">虚基类(派生来自有虚基类的先构造)</span><br><span class="line">A派生a1，a2，它们辆又派生出B，则将a1，a2声明为虚基类，就是在继承A时加virtual，对B来说只生成一份A的东西；</span><br><span class="line">如果x是A的成员，a1，a2各自又自己定义了自己版本，则B也要自定义自己版本</span><br><span class="line"></span><br><span class="line">#### cast_name &lt;type&gt;(expression)</span><br><span class="line">`static_cast`: 只要不包含底层const，都可以执行强制转换</span><br><span class="line">&gt;		void *p = &amp;d;	double *dp = static_cast&lt;double *&gt;(p);</span><br><span class="line"></span><br><span class="line">`const_cast`: 只能改变底层的const，变成不const的</span><br><span class="line">&gt;		const char *pc;	  char *p = const_cast&lt;char *&gt;(pc);</span><br><span class="line"></span><br><span class="line">`reinterpret_cast`：本质上依赖机器，不是特别了解，不安全</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 定义含有类型转换符的类</span><br><span class="line">**特性**</span><br><span class="line">	必须是类的成员函数，不能声明返回类型，没有形参，通常是const</span><br><span class="line">&gt;	operator int() const  &#123;return val; &#125;</span><br><span class="line"></span><br><span class="line">val原本是size_t类型可以定义为显式的，但当被用作条件语句是，编译器还是会自动转化</span><br><span class="line"></span><br><span class="line">#### iostream 迭代器：有`&gt;&gt;`的类型就可以创建</span><br><span class="line">例子：</span><br></pre></td></tr></table></figure><pre><code>istream_iterator&lt;int&gt; int_it(cin);//把istream_iterator绑定到一个流对象cin
istream_iterator&lt;int&gt; eof;//尾后迭代器，
while(int_it != eof)
..//eof被定义为空的istream_iterator。对于int_it,一旦其关联的流遇到文件尾或IO错误，迭代器就与尾后迭代器相等

ifstream in(&quot;afile&quot;);
istream_iterator&lt;string&gt; str_it(in);//绑定到afile,从afile读取

string text, word;
getline(in, text);
istringstream stream(text);
while(stream &gt;&gt; word)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">简写： 	istream_iterator&lt;int&gt; in_iter(cin), eof;//两个迭代器</span><br><span class="line">			vector&lt;int&gt; vec(in_iter, eof);//从cin读取元素构造vec，直到文件尾或不是int</span><br><span class="line">ostream 迭代器：有&lt;&lt;的类型就可以创建</span><br></pre></td></tr></table></figure><p>例子：</p><blockquote><p>ostream_iterator<int>out_iter(cout, ‘ ‘);//第二个参数可选，C字符串类型，在输出每个元素后打印该参数</int></p></blockquote><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>含义<br>未构造的对象用。其中参数必须用引用，因为没引用，相当于该参数要调用拷贝构造函数，它的上一任<br>也不是引用，也没构造出来，再用拷贝构造函数。。没完没了了嘿！是引用的话，表明形参就是实参，直接用<br>关于swap<br>若没有定义该类的swap，则默认为std::swap()<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Hasptr</span><br><span class="line">&#123;	</span><br><span class="line">	friend void swap(Hasptr &amp;, Hasprt &amp;)</span><br><span class="line">	private:</span><br><span class="line">		string *ps;</span><br><span class="line">&#125;;</span><br><span class="line">inline </span><br><span class="line">void swap(Hasptr &amp;lhs, Hasptr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps);//如果没定义Hasptr的swap，就会调用std的</span><br><span class="line">&#125;</span><br><span class="line">同理若一个类Foo有Hasptr的成员h</span><br><span class="line">void swap(Foo &amp;lhs, Foo &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	swap(lhs.h, rhs.h);//使用Hasptr版本的swap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在赋值运算中使用swap</span><br><span class="line">Hasptr&amp; Hasptr::operater=(Hasptr rhs)//传值，会拷贝一个副本</span><br><span class="line">&#123;</span><br><span class="line">	swap(*this, rhs);</span><br><span class="line">	return *this;//rhs是局部变量，被销毁，但因已指向this之前的内存，该内存被释放，正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数<br>总结：<br>一个类需要析构函数，则它必定需要拷贝构造函数和拷贝赋值函数<br>如果基类的析构函数函数不是虚函数：则delete一个指向派生类对象的基类指针将产生未定义后果</p><h4 id="标准库函数对象"><a href="#标准库函数对象" class="headerlink" title="标准库函数对象"></a>标准库函数对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;functional&gt;</span><br><span class="line">	negate&lt;int&gt; fu;		取负:int sum = fu(10);</span><br><span class="line">	plus&lt;T&gt;;</span><br><span class="line">	minus&lt;T&gt;;</span><br><span class="line">	multiplies&lt;T&gt;;</span><br><span class="line">	divides&lt;T&gt;;</span><br><span class="line">	modulus&lt;T&gt;			%</span><br><span class="line">	equal_to&lt;T&gt;			== </span><br><span class="line">	less&lt;T&gt;     		&lt;</span><br><span class="line">    </span><br><span class="line">    包括指针类型</span><br></pre></td></tr></table></figure><h4 id="function模板"><a href="#function模板" class="headerlink" title="function模板"></a>function模板</h4><pre><code>function&lt;T&gt; f;
f                 可作为条件判断，当f含有一个可调用对象时为真</code></pre><p>例子<br>lambda有自己的类类型，但我们可以统一，将它与我们所希望的类型匹配。但仅限于可调用类型(指针，函数，lambda)</p><pre><code>plus&lt;int&gt; add;
int add(int i, int j) {return i + j;};         //int (*add)..下面所说的&quot;更好&quot;
function&lt;int(int, int)&gt; f1 = add;
function&lt;int(int, int)&gt; f2 = divide();
function&lt;int(int, int)&gt; f3 = [] (int i, int j) {return i * j; };

map&lt;string, function&lt;int(int, int)&gt; &gt; binops = 
{
    { &quot;+&quot;, add },                在最初声明时定义为函数指针更好，遇同名的能消除二义性
    { &quot;-&quot;, std::minus&lt;int&gt; },
    { &quot;/&quot;, divide() },
    { &quot;*&quot;, [] (int i, int j) {return i * j;}  }//可以这样写
}</code></pre><h4 id="抛出异常-noexcept"><a href="#抛出异常-noexcept" class="headerlink" title="抛出异常 noexcept"></a>抛出异常 noexcept</h4><p>在参数列表和初始化列表冒号之前的位置写上，通知标准库，不会抛出异常，且在函数声明和定义处都要写上<br>如果不通知标准库，她为了保障一些行为，可能愿意使用拷贝构造函数来保证“源”不变。而移动正是会改变“源”，<br>包括异常时。所以为了不使用标准库的保障，必须与她交互</p><p>对可能真的会抛出异常的就不要使用了<br>typedef和类型别名中不能出现，在const及引用限定符之后，在final，override，虚函数=0之前，</p></utility><div class="post-announce">感谢您的阅读，本文由 <a href="https://github.com/BUGIsOne">Rakel's bolg</a> 版权所有。如若转载，请注明出处：Rakel's bolg（<a href="https://github.com/BUGIsOne/2019/09/17/c++基础语法学习/">https://github.com/BUGIsOne/2019/09/17/c++基础语法学习/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2019/09/17/blog搭建笔记/" title="skapp 主题博客搭建笔记"><i class="iconfont icon-prev"></i>skapp 主题博客搭建笔记</a></div><div class="post__prev post__prev--right"><a href="/2019/09/17/Linux基本命令手册/" title="linux基本命令手册">linux基本命令手册<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/os/">os</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/html/">html</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/c/">c++</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/algorithm/">algorithm</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/09/17/hello-world/" title="hello, world"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="hello, world"></div><div class="item__info"><h3 class="item__title">hello, world</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/Linux基本命令手册/" title="linux基本命令手册"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="linux基本命令手册"></div><div class="item__info"><h3 class="item__title">linux基本命令手册</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/c++基础语法学习/" title="c++基础语法学习"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="c++基础语法学习"></div><div class="item__info"><h3 class="item__title">c++基础语法学习</h3><span class="item__text">2019-09-17</span></div></a></li><li class="latest-post-item"><a href="/2019/09/17/blog搭建笔记/" title="skapp 主题博客搭建笔记"><div class="item__cover"><img src="../images/wallhaven-p8w2x3.jpg" alt="skapp 主题博客搭建笔记"></div><div class="item__info"><h3 class="item__title">skapp 主题博客搭建笔记</h3><span class="item__text">2019-09-17</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/blog/">blog</a></li><li class="tag-item"><a class="tag-link" href="/tags/kmp/">kmp</a></li><li class="tag-item"><a class="tag-link" href="/tags/linux/">linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/语法/">语法</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Chengdu, Sichuan Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>937459807@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="../images/IMG_20190917_184101.png" alt="logo" title="Rakel's bolg"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/BUGIsOne" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:937459807@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>